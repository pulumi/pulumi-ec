# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DeploymentApm',
    'DeploymentApmConfig',
    'DeploymentElasticsearch',
    'DeploymentElasticsearchCold',
    'DeploymentElasticsearchColdAutoscaling',
    'DeploymentElasticsearchConfig',
    'DeploymentElasticsearchCoordinating',
    'DeploymentElasticsearchCoordinatingAutoscaling',
    'DeploymentElasticsearchExtension',
    'DeploymentElasticsearchFrozen',
    'DeploymentElasticsearchFrozenAutoscaling',
    'DeploymentElasticsearchHot',
    'DeploymentElasticsearchHotAutoscaling',
    'DeploymentElasticsearchKeystoreContents',
    'DeploymentElasticsearchMaster',
    'DeploymentElasticsearchMasterAutoscaling',
    'DeploymentElasticsearchMl',
    'DeploymentElasticsearchMlAutoscaling',
    'DeploymentElasticsearchRemoteCluster',
    'DeploymentElasticsearchSnapshot',
    'DeploymentElasticsearchSnapshotRepository',
    'DeploymentElasticsearchSnapshotRepositoryReference',
    'DeploymentElasticsearchSnapshotSource',
    'DeploymentElasticsearchTrustAccount',
    'DeploymentElasticsearchTrustExternal',
    'DeploymentElasticsearchWarm',
    'DeploymentElasticsearchWarmAutoscaling',
    'DeploymentEnterpriseSearch',
    'DeploymentEnterpriseSearchConfig',
    'DeploymentIntegrationsServer',
    'DeploymentIntegrationsServerConfig',
    'DeploymentIntegrationsServerEndpoints',
    'DeploymentKibana',
    'DeploymentKibanaConfig',
    'DeploymentObservability',
    'DeploymentTrafficFilterRule',
    'SnapshotRepositoryGeneric',
    'SnapshotRepositoryS3',
    'GetDeploymentApmResult',
    'GetDeploymentApmTopologyResult',
    'GetDeploymentElasticsearchResult',
    'GetDeploymentElasticsearchTopologyResult',
    'GetDeploymentElasticsearchTopologyAutoscalingResult',
    'GetDeploymentEnterpriseSearchResult',
    'GetDeploymentEnterpriseSearchTopologyResult',
    'GetDeploymentIntegrationsServerResult',
    'GetDeploymentIntegrationsServerTopologyResult',
    'GetDeploymentKibanaResult',
    'GetDeploymentKibanaTopologyResult',
    'GetDeploymentObservabilityResult',
    'GetDeploymentsApmResult',
    'GetDeploymentsDeploymentResult',
    'GetDeploymentsElasticsearchResult',
    'GetDeploymentsEnterpriseSearchResult',
    'GetDeploymentsIntegrationsServerResult',
    'GetDeploymentsKibanaResult',
    'GetStackApmResult',
    'GetStackElasticsearchResult',
    'GetStackEnterpriseSearchResult',
    'GetStackKibanaResult',
    'GetTrafficFilterRulesetResult',
    'GetTrafficFilterRulesetRuleResult',
]

@pulumi.output_type
class DeploymentApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticsearchClusterRefId":
            suggest = "elasticsearch_cluster_ref_id"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpsEndpoint":
            suggest = "https_endpoint"
        elif key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional['outputs.DeploymentApmConfig'] = None,
                 elasticsearch_cluster_ref_id: Optional[str] = None,
                 http_endpoint: Optional[str] = None,
                 https_endpoint: Optional[str] = None,
                 instance_configuration_id: Optional[str] = None,
                 ref_id: Optional[str] = None,
                 region: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentApmConfigArgs' config: Optionally define the Apm configuration options for the APM Server
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentApm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            instance_configuration_id=instance_configuration_id,
            ref_id=ref_id,
            region=region,
            resource_id=resource_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional['outputs.DeploymentApmConfig'] = None,
             elasticsearch_cluster_ref_id: Optional[str] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             instance_configuration_id: Optional[str] = None,
             ref_id: Optional[str] = None,
             region: Optional[str] = None,
             resource_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        if config is not None:
            _setter("config", config)
        if elasticsearch_cluster_ref_id is not None:
            _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if https_endpoint is not None:
            _setter("https_endpoint", https_endpoint)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if ref_id is not None:
            _setter("ref_id", ref_id)
        if region is not None:
            _setter("region", region)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.DeploymentApmConfig']:
        """
        Optionally define the Apm configuration options for the APM Server
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentApmConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "debugEnabled":
            suggest = "debug_enabled"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "userSettingsJson":
            suggest = "user_settings_json"
        elif key == "userSettingsOverrideJson":
            suggest = "user_settings_override_json"
        elif key == "userSettingsOverrideYaml":
            suggest = "user_settings_override_yaml"
        elif key == "userSettingsYaml":
            suggest = "user_settings_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentApmConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentApmConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentApmConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 debug_enabled: Optional[bool] = None,
                 docker_image: Optional[str] = None,
                 user_settings_json: Optional[str] = None,
                 user_settings_override_json: Optional[str] = None,
                 user_settings_override_yaml: Optional[str] = None,
                 user_settings_yaml: Optional[str] = None):
        """
        :param bool debug_enabled: Optionally enable debug mode for APM servers - defaults to false
        :param str docker_image: Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        :param str user_settings_json: An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        :param str user_settings_override_json: An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_override_yaml: An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_yaml: An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        DeploymentApmConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            debug_enabled=debug_enabled,
            docker_image=docker_image,
            user_settings_json=user_settings_json,
            user_settings_override_json=user_settings_override_json,
            user_settings_override_yaml=user_settings_override_yaml,
            user_settings_yaml=user_settings_yaml,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             debug_enabled: Optional[bool] = None,
             docker_image: Optional[str] = None,
             user_settings_json: Optional[str] = None,
             user_settings_override_json: Optional[str] = None,
             user_settings_override_yaml: Optional[str] = None,
             user_settings_yaml: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if debug_enabled is None and 'debugEnabled' in kwargs:
            debug_enabled = kwargs['debugEnabled']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if user_settings_json is None and 'userSettingsJson' in kwargs:
            user_settings_json = kwargs['userSettingsJson']
        if user_settings_override_json is None and 'userSettingsOverrideJson' in kwargs:
            user_settings_override_json = kwargs['userSettingsOverrideJson']
        if user_settings_override_yaml is None and 'userSettingsOverrideYaml' in kwargs:
            user_settings_override_yaml = kwargs['userSettingsOverrideYaml']
        if user_settings_yaml is None and 'userSettingsYaml' in kwargs:
            user_settings_yaml = kwargs['userSettingsYaml']

        if debug_enabled is not None:
            _setter("debug_enabled", debug_enabled)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if user_settings_json is not None:
            _setter("user_settings_json", user_settings_json)
        if user_settings_override_json is not None:
            _setter("user_settings_override_json", user_settings_override_json)
        if user_settings_override_yaml is not None:
            _setter("user_settings_override_yaml", user_settings_override_yaml)
        if user_settings_yaml is not None:
            _setter("user_settings_yaml", user_settings_yaml)

    @property
    @pulumi.getter(name="debugEnabled")
    def debug_enabled(self) -> Optional[bool]:
        """
        Optionally enable debug mode for APM servers - defaults to false
        """
        return pulumi.get(self, "debug_enabled")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="userSettingsJson")
    def user_settings_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_json")

    @property
    @pulumi.getter(name="userSettingsOverrideJson")
    def user_settings_override_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_json")

    @property
    @pulumi.getter(name="userSettingsOverrideYaml")
    def user_settings_override_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_yaml")

    @property
    @pulumi.getter(name="userSettingsYaml")
    def user_settings_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_yaml")


@pulumi.output_type
class DeploymentElasticsearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudId":
            suggest = "cloud_id"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpsEndpoint":
            suggest = "https_endpoint"
        elif key == "keystoreContents":
            suggest = "keystore_contents"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "remoteClusters":
            suggest = "remote_clusters"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "snapshotSource":
            suggest = "snapshot_source"
        elif key == "trustAccounts":
            suggest = "trust_accounts"
        elif key == "trustExternals":
            suggest = "trust_externals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hot: 'outputs.DeploymentElasticsearchHot',
                 autoscale: Optional[bool] = None,
                 cloud_id: Optional[str] = None,
                 cold: Optional['outputs.DeploymentElasticsearchCold'] = None,
                 config: Optional['outputs.DeploymentElasticsearchConfig'] = None,
                 coordinating: Optional['outputs.DeploymentElasticsearchCoordinating'] = None,
                 extensions: Optional[Sequence['outputs.DeploymentElasticsearchExtension']] = None,
                 frozen: Optional['outputs.DeploymentElasticsearchFrozen'] = None,
                 http_endpoint: Optional[str] = None,
                 https_endpoint: Optional[str] = None,
                 keystore_contents: Optional[Mapping[str, 'outputs.DeploymentElasticsearchKeystoreContents']] = None,
                 master: Optional['outputs.DeploymentElasticsearchMaster'] = None,
                 ml: Optional['outputs.DeploymentElasticsearchMl'] = None,
                 ref_id: Optional[str] = None,
                 region: Optional[str] = None,
                 remote_clusters: Optional[Sequence['outputs.DeploymentElasticsearchRemoteCluster']] = None,
                 resource_id: Optional[str] = None,
                 snapshot: Optional['outputs.DeploymentElasticsearchSnapshot'] = None,
                 snapshot_source: Optional['outputs.DeploymentElasticsearchSnapshotSource'] = None,
                 strategy: Optional[str] = None,
                 trust_accounts: Optional[Sequence['outputs.DeploymentElasticsearchTrustAccount']] = None,
                 trust_externals: Optional[Sequence['outputs.DeploymentElasticsearchTrustExternal']] = None,
                 warm: Optional['outputs.DeploymentElasticsearchWarm'] = None):
        """
        :param 'DeploymentElasticsearchHotArgs' hot: 'hot' topology element
        :param bool autoscale: Enable or disable autoscaling. Defaults to the setting coming from the deployment template.
        :param 'DeploymentElasticsearchColdArgs' cold: 'cold' topology element
        :param 'DeploymentElasticsearchConfigArgs' config: Elasticsearch settings which will be applied to all topologies
        :param 'DeploymentElasticsearchCoordinatingArgs' coordinating: 'coordinating' topology element
        :param Sequence['DeploymentElasticsearchExtensionArgs'] extensions: Optional Elasticsearch extensions such as custom bundles or plugins.
        :param 'DeploymentElasticsearchFrozenArgs' frozen: 'frozen' topology element
        :param Mapping[str, 'DeploymentElasticsearchKeystoreContentsArgs'] keystore_contents: Keystore contents that are controlled by the deployment resource.
        :param 'DeploymentElasticsearchMasterArgs' master: 'master' topology element
        :param 'DeploymentElasticsearchMlArgs' ml: 'ml' topology element
        :param str ref_id: A human readable reference for the Elasticsearch resource. The default value `main-elasticsearch` is recommended.
        :param Sequence['DeploymentElasticsearchRemoteClusterArgs'] remote_clusters: Optional Elasticsearch remote clusters to configure for the Elasticsearch resource, can be set multiple times
        :param 'DeploymentElasticsearchSnapshotArgs' snapshot: (ECE only) Snapshot configuration settings for an Elasticsearch cluster.
        """
        DeploymentElasticsearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hot=hot,
            autoscale=autoscale,
            cloud_id=cloud_id,
            cold=cold,
            config=config,
            coordinating=coordinating,
            extensions=extensions,
            frozen=frozen,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            keystore_contents=keystore_contents,
            master=master,
            ml=ml,
            ref_id=ref_id,
            region=region,
            remote_clusters=remote_clusters,
            resource_id=resource_id,
            snapshot=snapshot,
            snapshot_source=snapshot_source,
            strategy=strategy,
            trust_accounts=trust_accounts,
            trust_externals=trust_externals,
            warm=warm,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hot: Optional['outputs.DeploymentElasticsearchHot'] = None,
             autoscale: Optional[bool] = None,
             cloud_id: Optional[str] = None,
             cold: Optional['outputs.DeploymentElasticsearchCold'] = None,
             config: Optional['outputs.DeploymentElasticsearchConfig'] = None,
             coordinating: Optional['outputs.DeploymentElasticsearchCoordinating'] = None,
             extensions: Optional[Sequence['outputs.DeploymentElasticsearchExtension']] = None,
             frozen: Optional['outputs.DeploymentElasticsearchFrozen'] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             keystore_contents: Optional[Mapping[str, 'outputs.DeploymentElasticsearchKeystoreContents']] = None,
             master: Optional['outputs.DeploymentElasticsearchMaster'] = None,
             ml: Optional['outputs.DeploymentElasticsearchMl'] = None,
             ref_id: Optional[str] = None,
             region: Optional[str] = None,
             remote_clusters: Optional[Sequence['outputs.DeploymentElasticsearchRemoteCluster']] = None,
             resource_id: Optional[str] = None,
             snapshot: Optional['outputs.DeploymentElasticsearchSnapshot'] = None,
             snapshot_source: Optional['outputs.DeploymentElasticsearchSnapshotSource'] = None,
             strategy: Optional[str] = None,
             trust_accounts: Optional[Sequence['outputs.DeploymentElasticsearchTrustAccount']] = None,
             trust_externals: Optional[Sequence['outputs.DeploymentElasticsearchTrustExternal']] = None,
             warm: Optional['outputs.DeploymentElasticsearchWarm'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if hot is None:
            raise TypeError("Missing 'hot' argument")
        if cloud_id is None and 'cloudId' in kwargs:
            cloud_id = kwargs['cloudId']
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if keystore_contents is None and 'keystoreContents' in kwargs:
            keystore_contents = kwargs['keystoreContents']
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if remote_clusters is None and 'remoteClusters' in kwargs:
            remote_clusters = kwargs['remoteClusters']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if snapshot_source is None and 'snapshotSource' in kwargs:
            snapshot_source = kwargs['snapshotSource']
        if trust_accounts is None and 'trustAccounts' in kwargs:
            trust_accounts = kwargs['trustAccounts']
        if trust_externals is None and 'trustExternals' in kwargs:
            trust_externals = kwargs['trustExternals']

        _setter("hot", hot)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if cloud_id is not None:
            _setter("cloud_id", cloud_id)
        if cold is not None:
            _setter("cold", cold)
        if config is not None:
            _setter("config", config)
        if coordinating is not None:
            _setter("coordinating", coordinating)
        if extensions is not None:
            _setter("extensions", extensions)
        if frozen is not None:
            _setter("frozen", frozen)
        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if https_endpoint is not None:
            _setter("https_endpoint", https_endpoint)
        if keystore_contents is not None:
            _setter("keystore_contents", keystore_contents)
        if master is not None:
            _setter("master", master)
        if ml is not None:
            _setter("ml", ml)
        if ref_id is not None:
            _setter("ref_id", ref_id)
        if region is not None:
            _setter("region", region)
        if remote_clusters is not None:
            _setter("remote_clusters", remote_clusters)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if snapshot is not None:
            _setter("snapshot", snapshot)
        if snapshot_source is not None:
            _setter("snapshot_source", snapshot_source)
        if strategy is not None:
            _setter("strategy", strategy)
        if trust_accounts is not None:
            _setter("trust_accounts", trust_accounts)
        if trust_externals is not None:
            _setter("trust_externals", trust_externals)
        if warm is not None:
            _setter("warm", warm)

    @property
    @pulumi.getter
    def hot(self) -> 'outputs.DeploymentElasticsearchHot':
        """
        'hot' topology element
        """
        return pulumi.get(self, "hot")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        Enable or disable autoscaling. Defaults to the setting coming from the deployment template.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[str]:
        return pulumi.get(self, "cloud_id")

    @property
    @pulumi.getter
    def cold(self) -> Optional['outputs.DeploymentElasticsearchCold']:
        """
        'cold' topology element
        """
        return pulumi.get(self, "cold")

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.DeploymentElasticsearchConfig']:
        """
        Elasticsearch settings which will be applied to all topologies
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def coordinating(self) -> Optional['outputs.DeploymentElasticsearchCoordinating']:
        """
        'coordinating' topology element
        """
        return pulumi.get(self, "coordinating")

    @property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.DeploymentElasticsearchExtension']]:
        """
        Optional Elasticsearch extensions such as custom bundles or plugins.
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter
    def frozen(self) -> Optional['outputs.DeploymentElasticsearchFrozen']:
        """
        'frozen' topology element
        """
        return pulumi.get(self, "frozen")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="keystoreContents")
    def keystore_contents(self) -> Optional[Mapping[str, 'outputs.DeploymentElasticsearchKeystoreContents']]:
        """
        Keystore contents that are controlled by the deployment resource.
        """
        return pulumi.get(self, "keystore_contents")

    @property
    @pulumi.getter
    def master(self) -> Optional['outputs.DeploymentElasticsearchMaster']:
        """
        'master' topology element
        """
        return pulumi.get(self, "master")

    @property
    @pulumi.getter
    def ml(self) -> Optional['outputs.DeploymentElasticsearchMl']:
        """
        'ml' topology element
        """
        return pulumi.get(self, "ml")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        """
        A human readable reference for the Elasticsearch resource. The default value `main-elasticsearch` is recommended.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="remoteClusters")
    def remote_clusters(self) -> Optional[Sequence['outputs.DeploymentElasticsearchRemoteCluster']]:
        """
        Optional Elasticsearch remote clusters to configure for the Elasticsearch resource, can be set multiple times
        """
        return pulumi.get(self, "remote_clusters")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DeploymentElasticsearchSnapshot']:
        """
        (ECE only) Snapshot configuration settings for an Elasticsearch cluster.
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter(name="snapshotSource")
    def snapshot_source(self) -> Optional['outputs.DeploymentElasticsearchSnapshotSource']:
        return pulumi.get(self, "snapshot_source")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="trustAccounts")
    def trust_accounts(self) -> Optional[Sequence['outputs.DeploymentElasticsearchTrustAccount']]:
        return pulumi.get(self, "trust_accounts")

    @property
    @pulumi.getter(name="trustExternals")
    def trust_externals(self) -> Optional[Sequence['outputs.DeploymentElasticsearchTrustExternal']]:
        return pulumi.get(self, "trust_externals")

    @property
    @pulumi.getter
    def warm(self) -> Optional['outputs.DeploymentElasticsearchWarm']:
        return pulumi.get(self, "warm")


@pulumi.output_type
class DeploymentElasticsearchCold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchCold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchCold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchCold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchColdAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchColdAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchCold._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchColdAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchColdAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchColdAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchColdAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchColdAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchColdAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchColdAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentElasticsearchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "userSettingsJson":
            suggest = "user_settings_json"
        elif key == "userSettingsOverrideJson":
            suggest = "user_settings_override_json"
        elif key == "userSettingsOverrideYaml":
            suggest = "user_settings_override_yaml"
        elif key == "userSettingsYaml":
            suggest = "user_settings_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 plugins: Optional[Sequence[str]] = None,
                 user_settings_json: Optional[str] = None,
                 user_settings_override_json: Optional[str] = None,
                 user_settings_override_yaml: Optional[str] = None,
                 user_settings_yaml: Optional[str] = None):
        """
        :param str docker_image: Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        :param Sequence[str] plugins: List of Elasticsearch supported plugins, which vary from version to version. Check the Stack Pack version to see which plugins are supported for each version. This is currently only available from the UI and [ecctl](https://www.elastic.co/guide/en/ecctl/master/ecctl_stack_list.html)
        :param str user_settings_json: An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        :param str user_settings_override_json: An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_override_yaml: An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_yaml: An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        DeploymentElasticsearchConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            docker_image=docker_image,
            plugins=plugins,
            user_settings_json=user_settings_json,
            user_settings_override_json=user_settings_override_json,
            user_settings_override_yaml=user_settings_override_yaml,
            user_settings_yaml=user_settings_yaml,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             docker_image: Optional[str] = None,
             plugins: Optional[Sequence[str]] = None,
             user_settings_json: Optional[str] = None,
             user_settings_override_json: Optional[str] = None,
             user_settings_override_yaml: Optional[str] = None,
             user_settings_yaml: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if user_settings_json is None and 'userSettingsJson' in kwargs:
            user_settings_json = kwargs['userSettingsJson']
        if user_settings_override_json is None and 'userSettingsOverrideJson' in kwargs:
            user_settings_override_json = kwargs['userSettingsOverrideJson']
        if user_settings_override_yaml is None and 'userSettingsOverrideYaml' in kwargs:
            user_settings_override_yaml = kwargs['userSettingsOverrideYaml']
        if user_settings_yaml is None and 'userSettingsYaml' in kwargs:
            user_settings_yaml = kwargs['userSettingsYaml']

        if docker_image is not None:
            _setter("docker_image", docker_image)
        if plugins is not None:
            _setter("plugins", plugins)
        if user_settings_json is not None:
            _setter("user_settings_json", user_settings_json)
        if user_settings_override_json is not None:
            _setter("user_settings_override_json", user_settings_override_json)
        if user_settings_override_yaml is not None:
            _setter("user_settings_override_yaml", user_settings_override_yaml)
        if user_settings_yaml is not None:
            _setter("user_settings_yaml", user_settings_yaml)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence[str]]:
        """
        List of Elasticsearch supported plugins, which vary from version to version. Check the Stack Pack version to see which plugins are supported for each version. This is currently only available from the UI and [ecctl](https://www.elastic.co/guide/en/ecctl/master/ecctl_stack_list.html)
        """
        return pulumi.get(self, "plugins")

    @property
    @pulumi.getter(name="userSettingsJson")
    def user_settings_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_json")

    @property
    @pulumi.getter(name="userSettingsOverrideJson")
    def user_settings_override_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_json")

    @property
    @pulumi.getter(name="userSettingsOverrideYaml")
    def user_settings_override_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_yaml")

    @property
    @pulumi.getter(name="userSettingsYaml")
    def user_settings_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_yaml")


@pulumi.output_type
class DeploymentElasticsearchCoordinating(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchCoordinating. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchCoordinating.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchCoordinating.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchCoordinatingAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchCoordinatingAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchCoordinating._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchCoordinatingAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchCoordinatingAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchCoordinatingAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchCoordinatingAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchCoordinatingAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchCoordinatingAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchCoordinatingAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentElasticsearchExtension(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 url: str,
                 version: str):
        """
        :param str name: Extension name.
        :param str type: Extension type, only `bundle` or `plugin` are supported.
        :param str url: Bundle or plugin URL, the extension URL can be obtained from the `ec_deployment_extension.<name>.url` attribute or the API and cannot be a random HTTP address that is hosted elsewhere.
        :param str version: Elasticsearch compatibility version. Bundles should specify major or minor versions with wildcards, such as `7.*` or `*` but **plugins must use full version notation down to the patch level**, such as `7.10.1` and wildcards are not allowed.
        """
        DeploymentElasticsearchExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            url=url,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             url: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("name", name)
        _setter("type", type)
        _setter("url", url)
        _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Extension name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Extension type, only `bundle` or `plugin` are supported.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Bundle or plugin URL, the extension URL can be obtained from the `ec_deployment_extension.<name>.url` attribute or the API and cannot be a random HTTP address that is hosted elsewhere.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Elasticsearch compatibility version. Bundles should specify major or minor versions with wildcards, such as `7.*` or `*` but **plugins must use full version notation down to the patch level**, such as `7.10.1` and wildcards are not allowed.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DeploymentElasticsearchFrozen(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchFrozen. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchFrozen.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchFrozen.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchFrozenAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchFrozenAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchFrozen._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchFrozenAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchFrozenAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchFrozenAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchFrozenAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchFrozenAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchFrozenAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchFrozenAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentElasticsearchHot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchHot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchHot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchHot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchHotAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchHotAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchHot._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchHotAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchHotAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchHotAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchHotAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchHotAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchHotAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchHotAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentElasticsearchKeystoreContents(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asFile":
            suggest = "as_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchKeystoreContents. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchKeystoreContents.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchKeystoreContents.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 as_file: Optional[bool] = None):
        """
        :param str value: Secret value. This can either be a string or a JSON object that is stored as a JSON string in the keystore.
        :param bool as_file: If true, the secret is handled as a file. Otherwise, it's handled as a plain string.
        """
        DeploymentElasticsearchKeystoreContents._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            as_file=as_file,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[str] = None,
             as_file: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")
        if as_file is None and 'asFile' in kwargs:
            as_file = kwargs['asFile']

        _setter("value", value)
        if as_file is not None:
            _setter("as_file", as_file)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Secret value. This can either be a string or a JSON object that is stored as a JSON string in the keystore.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="asFile")
    def as_file(self) -> Optional[bool]:
        """
        If true, the secret is handled as a file. Otherwise, it's handled as a plain string.
        """
        return pulumi.get(self, "as_file")


@pulumi.output_type
class DeploymentElasticsearchMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchMasterAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchMasterAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchMaster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchMasterAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchMasterAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchMasterAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchMasterAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchMasterAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchMasterAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchMasterAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentElasticsearchMl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchMl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchMl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchMl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchMlAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchMlAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchMl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchMlAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchMlAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchMlAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchMlAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchMlAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchMlAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchMlAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentElasticsearchRemoteCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "skipUnavailable":
            suggest = "skip_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchRemoteCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchRemoteCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchRemoteCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: str,
                 deployment_id: str,
                 ref_id: Optional[str] = None,
                 skip_unavailable: Optional[bool] = None):
        """
        :param str alias: Alias for this Cross Cluster Search binding
        :param str deployment_id: Remote deployment ID
        :param bool skip_unavailable: If true, skip the cluster during search when disconnected
        """
        DeploymentElasticsearchRemoteCluster._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            deployment_id=deployment_id,
            ref_id=ref_id,
            skip_unavailable=skip_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             deployment_id: Optional[str] = None,
             ref_id: Optional[str] = None,
             skip_unavailable: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if deployment_id is None and 'deploymentId' in kwargs:
            deployment_id = kwargs['deploymentId']
        if deployment_id is None:
            raise TypeError("Missing 'deployment_id' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if skip_unavailable is None and 'skipUnavailable' in kwargs:
            skip_unavailable = kwargs['skipUnavailable']

        _setter("alias", alias)
        _setter("deployment_id", deployment_id)
        if ref_id is not None:
            _setter("ref_id", ref_id)
        if skip_unavailable is not None:
            _setter("skip_unavailable", skip_unavailable)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        Alias for this Cross Cluster Search binding
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        """
        Remote deployment ID
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="skipUnavailable")
    def skip_unavailable(self) -> Optional[bool]:
        """
        If true, skip the cluster during search when disconnected
        """
        return pulumi.get(self, "skip_unavailable")


@pulumi.output_type
class DeploymentElasticsearchSnapshot(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 repository: Optional['outputs.DeploymentElasticsearchSnapshotRepository'] = None):
        """
        :param bool enabled: Indicates if Snapshotting is enabled.
        :param 'DeploymentElasticsearchSnapshotRepositoryArgs' repository: Snapshot repository configuration
        """
        DeploymentElasticsearchSnapshot._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            repository=repository,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             repository: Optional['outputs.DeploymentElasticsearchSnapshotRepository'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)
        if repository is not None:
            _setter("repository", repository)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates if Snapshotting is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def repository(self) -> Optional['outputs.DeploymentElasticsearchSnapshotRepository']:
        """
        Snapshot repository configuration
        """
        return pulumi.get(self, "repository")


@pulumi.output_type
class DeploymentElasticsearchSnapshotRepository(dict):
    def __init__(__self__, *,
                 reference: Optional['outputs.DeploymentElasticsearchSnapshotRepositoryReference'] = None):
        """
        :param 'DeploymentElasticsearchSnapshotRepositoryReferenceArgs' reference: Cluster snapshot reference repository settings, containing the repository name in ECE fashion
        """
        DeploymentElasticsearchSnapshotRepository._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference=reference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference: Optional['outputs.DeploymentElasticsearchSnapshotRepositoryReference'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if reference is not None:
            _setter("reference", reference)

    @property
    @pulumi.getter
    def reference(self) -> Optional['outputs.DeploymentElasticsearchSnapshotRepositoryReference']:
        """
        Cluster snapshot reference repository settings, containing the repository name in ECE fashion
        """
        return pulumi.get(self, "reference")


@pulumi.output_type
class DeploymentElasticsearchSnapshotRepositoryReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryName":
            suggest = "repository_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchSnapshotRepositoryReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchSnapshotRepositoryReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchSnapshotRepositoryReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository_name: str):
        """
        :param str repository_name: ECE snapshot repository name, from the '/platform/configuration/snapshots/repositories' endpoint
        """
        DeploymentElasticsearchSnapshotRepositoryReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            repository_name=repository_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             repository_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if repository_name is None and 'repositoryName' in kwargs:
            repository_name = kwargs['repositoryName']
        if repository_name is None:
            raise TypeError("Missing 'repository_name' argument")

        _setter("repository_name", repository_name)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        ECE snapshot repository name, from the '/platform/configuration/snapshots/repositories' endpoint
        """
        return pulumi.get(self, "repository_name")


@pulumi.output_type
class DeploymentElasticsearchSnapshotSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceElasticsearchClusterId":
            suggest = "source_elasticsearch_cluster_id"
        elif key == "snapshotName":
            suggest = "snapshot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchSnapshotSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchSnapshotSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchSnapshotSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_elasticsearch_cluster_id: str,
                 snapshot_name: Optional[str] = None):
        """
        :param str source_elasticsearch_cluster_id: ID of the Elasticsearch cluster that will be used as the source of the snapshot
        :param str snapshot_name: Name of the snapshot to restore. Use '**latest_success**' to get the most recent successful snapshot.
        """
        DeploymentElasticsearchSnapshotSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_elasticsearch_cluster_id=source_elasticsearch_cluster_id,
            snapshot_name=snapshot_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_elasticsearch_cluster_id: Optional[str] = None,
             snapshot_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if source_elasticsearch_cluster_id is None and 'sourceElasticsearchClusterId' in kwargs:
            source_elasticsearch_cluster_id = kwargs['sourceElasticsearchClusterId']
        if source_elasticsearch_cluster_id is None:
            raise TypeError("Missing 'source_elasticsearch_cluster_id' argument")
        if snapshot_name is None and 'snapshotName' in kwargs:
            snapshot_name = kwargs['snapshotName']

        _setter("source_elasticsearch_cluster_id", source_elasticsearch_cluster_id)
        if snapshot_name is not None:
            _setter("snapshot_name", snapshot_name)

    @property
    @pulumi.getter(name="sourceElasticsearchClusterId")
    def source_elasticsearch_cluster_id(self) -> str:
        """
        ID of the Elasticsearch cluster that will be used as the source of the snapshot
        """
        return pulumi.get(self, "source_elasticsearch_cluster_id")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[str]:
        """
        Name of the snapshot to restore. Use '**latest_success**' to get the most recent successful snapshot.
        """
        return pulumi.get(self, "snapshot_name")


@pulumi.output_type
class DeploymentElasticsearchTrustAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "trustAll":
            suggest = "trust_all"
        elif key == "trustAllowlists":
            suggest = "trust_allowlists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchTrustAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchTrustAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchTrustAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 trust_all: bool,
                 trust_allowlists: Optional[Sequence[str]] = None):
        """
        :param str account_id: The ID of the Account.
        :param bool trust_all: If true, all clusters in this account will by default be trusted and the `trust_allowlist` is ignored.
        :param Sequence[str] trust_allowlists: The list of clusters to trust. Only used when `trust_all` is false.
        """
        DeploymentElasticsearchTrustAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            trust_all=trust_all,
            trust_allowlists=trust_allowlists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             trust_all: Optional[bool] = None,
             trust_allowlists: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if account_id is None:
            raise TypeError("Missing 'account_id' argument")
        if trust_all is None and 'trustAll' in kwargs:
            trust_all = kwargs['trustAll']
        if trust_all is None:
            raise TypeError("Missing 'trust_all' argument")
        if trust_allowlists is None and 'trustAllowlists' in kwargs:
            trust_allowlists = kwargs['trustAllowlists']

        _setter("account_id", account_id)
        _setter("trust_all", trust_all)
        if trust_allowlists is not None:
            _setter("trust_allowlists", trust_allowlists)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The ID of the Account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="trustAll")
    def trust_all(self) -> bool:
        """
        If true, all clusters in this account will by default be trusted and the `trust_allowlist` is ignored.
        """
        return pulumi.get(self, "trust_all")

    @property
    @pulumi.getter(name="trustAllowlists")
    def trust_allowlists(self) -> Optional[Sequence[str]]:
        """
        The list of clusters to trust. Only used when `trust_all` is false.
        """
        return pulumi.get(self, "trust_allowlists")


@pulumi.output_type
class DeploymentElasticsearchTrustExternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relationshipId":
            suggest = "relationship_id"
        elif key == "trustAll":
            suggest = "trust_all"
        elif key == "trustAllowlists":
            suggest = "trust_allowlists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchTrustExternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchTrustExternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchTrustExternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relationship_id: str,
                 trust_all: bool,
                 trust_allowlists: Optional[Sequence[str]] = None):
        """
        :param str relationship_id: The ID of the external trust relationship.
        :param bool trust_all: If true, all clusters in this account will by default be trusted and the `trust_allowlist` is ignored.
        :param Sequence[str] trust_allowlists: The list of clusters to trust. Only used when `trust_all` is false.
        """
        DeploymentElasticsearchTrustExternal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            relationship_id=relationship_id,
            trust_all=trust_all,
            trust_allowlists=trust_allowlists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             relationship_id: Optional[str] = None,
             trust_all: Optional[bool] = None,
             trust_allowlists: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if relationship_id is None and 'relationshipId' in kwargs:
            relationship_id = kwargs['relationshipId']
        if relationship_id is None:
            raise TypeError("Missing 'relationship_id' argument")
        if trust_all is None and 'trustAll' in kwargs:
            trust_all = kwargs['trustAll']
        if trust_all is None:
            raise TypeError("Missing 'trust_all' argument")
        if trust_allowlists is None and 'trustAllowlists' in kwargs:
            trust_allowlists = kwargs['trustAllowlists']

        _setter("relationship_id", relationship_id)
        _setter("trust_all", trust_all)
        if trust_allowlists is not None:
            _setter("trust_allowlists", trust_allowlists)

    @property
    @pulumi.getter(name="relationshipId")
    def relationship_id(self) -> str:
        """
        The ID of the external trust relationship.
        """
        return pulumi.get(self, "relationship_id")

    @property
    @pulumi.getter(name="trustAll")
    def trust_all(self) -> bool:
        """
        If true, all clusters in this account will by default be trusted and the `trust_allowlist` is ignored.
        """
        return pulumi.get(self, "trust_all")

    @property
    @pulumi.getter(name="trustAllowlists")
    def trust_allowlists(self) -> Optional[Sequence[str]]:
        """
        The list of clusters to trust. Only used when `trust_all` is false.
        """
        return pulumi.get(self, "trust_allowlists")


@pulumi.output_type
class DeploymentElasticsearchWarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeRoles":
            suggest = "node_roles"
        elif key == "nodeTypeData":
            suggest = "node_type_data"
        elif key == "nodeTypeIngest":
            suggest = "node_type_ingest"
        elif key == "nodeTypeMaster":
            suggest = "node_type_master"
        elif key == "nodeTypeMl":
            suggest = "node_type_ml"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchWarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchWarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchWarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.DeploymentElasticsearchWarmAutoscaling',
                 instance_configuration_id: Optional[str] = None,
                 node_roles: Optional[Sequence[str]] = None,
                 node_type_data: Optional[str] = None,
                 node_type_ingest: Optional[str] = None,
                 node_type_master: Optional[str] = None,
                 node_type_ml: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentElasticsearchWarmAutoscalingArgs' autoscaling: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param Sequence[str] node_roles: The computed list of node roles for the current topology element
        :param str node_type_data: The node type for the Elasticsearch Topology element (data node)
        :param str node_type_ingest: The node type for the Elasticsearch Topology element (ingest node)
        :param str node_type_master: The node type for the Elasticsearch Topology element (master node)
        :param str node_type_ml: The node type for the Elasticsearch Topology element (machine learning node)
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentElasticsearchWarm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.DeploymentElasticsearchWarmAutoscaling'] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[str] = None,
             node_type_ingest: Optional[str] = None,
             node_type_master: Optional[str] = None,
             node_type_ml: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscaling is None:
            raise TypeError("Missing 'autoscaling' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        _setter("autoscaling", autoscaling)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_roles is not None:
            _setter("node_roles", node_roles)
        if node_type_data is not None:
            _setter("node_type_data", node_type_data)
        if node_type_ingest is not None:
            _setter("node_type_ingest", node_type_ingest)
        if node_type_master is not None:
            _setter("node_type_master", node_type_master)
        if node_type_ml is not None:
            _setter("node_type_ml", node_type_ml)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.DeploymentElasticsearchWarmAutoscaling':
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Optional[Sequence[str]]:
        """
        The computed list of node roles for the current topology element
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (data node)
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (ingest node)
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (master node)
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> Optional[str]:
        """
        The node type for the Elasticsearch Topology element (machine learning node)
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentElasticsearchWarmAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "maxSizeResource":
            suggest = "max_size_resource"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "minSizeResource":
            suggest = "min_size_resource"
        elif key == "policyOverrideJson":
            suggest = "policy_override_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentElasticsearchWarmAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentElasticsearchWarmAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentElasticsearchWarmAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[str] = None,
                 max_size_resource: Optional[str] = None,
                 min_size: Optional[str] = None,
                 min_size_resource: Optional[str] = None,
                 policy_override_json: Optional[str] = None):
        """
        :param str max_size: Maximum size value for the maximum autoscaling setting.
        :param str max_size_resource: Maximum resource type for the maximum autoscaling setting.
        :param str min_size: Minimum size value for the minimum autoscaling setting.
        :param str min_size_resource: Minimum resource type for the minimum autoscaling setting.
        :param str policy_override_json: Computed policy overrides set directly via the API or other clients.
        """
        DeploymentElasticsearchWarmAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']

        if max_size is not None:
            _setter("max_size", max_size)
        if max_size_resource is not None:
            _setter("max_size_resource", max_size_resource)
        if min_size is not None:
            _setter("min_size", min_size)
        if min_size_resource is not None:
            _setter("min_size_resource", min_size_resource)
        if policy_override_json is not None:
            _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size value for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> Optional[str]:
        """
        Maximum resource type for the maximum autoscaling setting.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size value for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> Optional[str]:
        """
        Minimum resource type for the minimum autoscaling setting.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> Optional[str]:
        """
        Computed policy overrides set directly via the API or other clients.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class DeploymentEnterpriseSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticsearchClusterRefId":
            suggest = "elasticsearch_cluster_ref_id"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpsEndpoint":
            suggest = "https_endpoint"
        elif key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "nodeTypeAppserver":
            suggest = "node_type_appserver"
        elif key == "nodeTypeConnector":
            suggest = "node_type_connector"
        elif key == "nodeTypeWorker":
            suggest = "node_type_worker"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentEnterpriseSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentEnterpriseSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentEnterpriseSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional['outputs.DeploymentEnterpriseSearchConfig'] = None,
                 elasticsearch_cluster_ref_id: Optional[str] = None,
                 http_endpoint: Optional[str] = None,
                 https_endpoint: Optional[str] = None,
                 instance_configuration_id: Optional[str] = None,
                 node_type_appserver: Optional[bool] = None,
                 node_type_connector: Optional[bool] = None,
                 node_type_worker: Optional[bool] = None,
                 ref_id: Optional[str] = None,
                 region: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentEnterpriseSearchConfigArgs' config: Optionally define the Enterprise Search configuration options for the Enterprise Search Server
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentEnterpriseSearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            instance_configuration_id=instance_configuration_id,
            node_type_appserver=node_type_appserver,
            node_type_connector=node_type_connector,
            node_type_worker=node_type_worker,
            ref_id=ref_id,
            region=region,
            resource_id=resource_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional['outputs.DeploymentEnterpriseSearchConfig'] = None,
             elasticsearch_cluster_ref_id: Optional[str] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             instance_configuration_id: Optional[str] = None,
             node_type_appserver: Optional[bool] = None,
             node_type_connector: Optional[bool] = None,
             node_type_worker: Optional[bool] = None,
             ref_id: Optional[str] = None,
             region: Optional[str] = None,
             resource_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if node_type_appserver is None and 'nodeTypeAppserver' in kwargs:
            node_type_appserver = kwargs['nodeTypeAppserver']
        if node_type_connector is None and 'nodeTypeConnector' in kwargs:
            node_type_connector = kwargs['nodeTypeConnector']
        if node_type_worker is None and 'nodeTypeWorker' in kwargs:
            node_type_worker = kwargs['nodeTypeWorker']
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        if config is not None:
            _setter("config", config)
        if elasticsearch_cluster_ref_id is not None:
            _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if https_endpoint is not None:
            _setter("https_endpoint", https_endpoint)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if node_type_appserver is not None:
            _setter("node_type_appserver", node_type_appserver)
        if node_type_connector is not None:
            _setter("node_type_connector", node_type_connector)
        if node_type_worker is not None:
            _setter("node_type_worker", node_type_worker)
        if ref_id is not None:
            _setter("ref_id", ref_id)
        if region is not None:
            _setter("region", region)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.DeploymentEnterpriseSearchConfig']:
        """
        Optionally define the Enterprise Search configuration options for the Enterprise Search Server
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeTypeAppserver")
    def node_type_appserver(self) -> Optional[bool]:
        return pulumi.get(self, "node_type_appserver")

    @property
    @pulumi.getter(name="nodeTypeConnector")
    def node_type_connector(self) -> Optional[bool]:
        return pulumi.get(self, "node_type_connector")

    @property
    @pulumi.getter(name="nodeTypeWorker")
    def node_type_worker(self) -> Optional[bool]:
        return pulumi.get(self, "node_type_worker")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentEnterpriseSearchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "userSettingsJson":
            suggest = "user_settings_json"
        elif key == "userSettingsOverrideJson":
            suggest = "user_settings_override_json"
        elif key == "userSettingsOverrideYaml":
            suggest = "user_settings_override_yaml"
        elif key == "userSettingsYaml":
            suggest = "user_settings_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentEnterpriseSearchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentEnterpriseSearchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentEnterpriseSearchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 user_settings_json: Optional[str] = None,
                 user_settings_override_json: Optional[str] = None,
                 user_settings_override_yaml: Optional[str] = None,
                 user_settings_yaml: Optional[str] = None):
        """
        :param str docker_image: Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        :param str user_settings_json: An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        :param str user_settings_override_json: An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_override_yaml: An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_yaml: An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        DeploymentEnterpriseSearchConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            docker_image=docker_image,
            user_settings_json=user_settings_json,
            user_settings_override_json=user_settings_override_json,
            user_settings_override_yaml=user_settings_override_yaml,
            user_settings_yaml=user_settings_yaml,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             docker_image: Optional[str] = None,
             user_settings_json: Optional[str] = None,
             user_settings_override_json: Optional[str] = None,
             user_settings_override_yaml: Optional[str] = None,
             user_settings_yaml: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if user_settings_json is None and 'userSettingsJson' in kwargs:
            user_settings_json = kwargs['userSettingsJson']
        if user_settings_override_json is None and 'userSettingsOverrideJson' in kwargs:
            user_settings_override_json = kwargs['userSettingsOverrideJson']
        if user_settings_override_yaml is None and 'userSettingsOverrideYaml' in kwargs:
            user_settings_override_yaml = kwargs['userSettingsOverrideYaml']
        if user_settings_yaml is None and 'userSettingsYaml' in kwargs:
            user_settings_yaml = kwargs['userSettingsYaml']

        if docker_image is not None:
            _setter("docker_image", docker_image)
        if user_settings_json is not None:
            _setter("user_settings_json", user_settings_json)
        if user_settings_override_json is not None:
            _setter("user_settings_override_json", user_settings_override_json)
        if user_settings_override_yaml is not None:
            _setter("user_settings_override_yaml", user_settings_override_yaml)
        if user_settings_yaml is not None:
            _setter("user_settings_yaml", user_settings_yaml)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="userSettingsJson")
    def user_settings_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_json")

    @property
    @pulumi.getter(name="userSettingsOverrideJson")
    def user_settings_override_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_json")

    @property
    @pulumi.getter(name="userSettingsOverrideYaml")
    def user_settings_override_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_yaml")

    @property
    @pulumi.getter(name="userSettingsYaml")
    def user_settings_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_yaml")


@pulumi.output_type
class DeploymentIntegrationsServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticsearchClusterRefId":
            suggest = "elasticsearch_cluster_ref_id"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpsEndpoint":
            suggest = "https_endpoint"
        elif key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentIntegrationsServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentIntegrationsServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentIntegrationsServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional['outputs.DeploymentIntegrationsServerConfig'] = None,
                 elasticsearch_cluster_ref_id: Optional[str] = None,
                 endpoints: Optional['outputs.DeploymentIntegrationsServerEndpoints'] = None,
                 http_endpoint: Optional[str] = None,
                 https_endpoint: Optional[str] = None,
                 instance_configuration_id: Optional[str] = None,
                 ref_id: Optional[str] = None,
                 region: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentIntegrationsServerConfigArgs' config: Optionally define the Integrations Server configuration options for the IntegrationsServer Server
        :param 'DeploymentIntegrationsServerEndpointsArgs' endpoints: URLs for the accessing the Fleet and APM API's within this Integrations Server resource.
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentIntegrationsServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            endpoints=endpoints,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            instance_configuration_id=instance_configuration_id,
            ref_id=ref_id,
            region=region,
            resource_id=resource_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional['outputs.DeploymentIntegrationsServerConfig'] = None,
             elasticsearch_cluster_ref_id: Optional[str] = None,
             endpoints: Optional['outputs.DeploymentIntegrationsServerEndpoints'] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             instance_configuration_id: Optional[str] = None,
             ref_id: Optional[str] = None,
             region: Optional[str] = None,
             resource_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        if config is not None:
            _setter("config", config)
        if elasticsearch_cluster_ref_id is not None:
            _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        if endpoints is not None:
            _setter("endpoints", endpoints)
        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if https_endpoint is not None:
            _setter("https_endpoint", https_endpoint)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if ref_id is not None:
            _setter("ref_id", ref_id)
        if region is not None:
            _setter("region", region)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.DeploymentIntegrationsServerConfig']:
        """
        Optionally define the Integrations Server configuration options for the IntegrationsServer Server
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional['outputs.DeploymentIntegrationsServerEndpoints']:
        """
        URLs for the accessing the Fleet and APM API's within this Integrations Server resource.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentIntegrationsServerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "debugEnabled":
            suggest = "debug_enabled"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "userSettingsJson":
            suggest = "user_settings_json"
        elif key == "userSettingsOverrideJson":
            suggest = "user_settings_override_json"
        elif key == "userSettingsOverrideYaml":
            suggest = "user_settings_override_yaml"
        elif key == "userSettingsYaml":
            suggest = "user_settings_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentIntegrationsServerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentIntegrationsServerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentIntegrationsServerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 debug_enabled: Optional[bool] = None,
                 docker_image: Optional[str] = None,
                 user_settings_json: Optional[str] = None,
                 user_settings_override_json: Optional[str] = None,
                 user_settings_override_yaml: Optional[str] = None,
                 user_settings_yaml: Optional[str] = None):
        """
        :param bool debug_enabled: Optionally enable debug mode for APM servers - defaults to false
        :param str docker_image: Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        :param str user_settings_json: An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        :param str user_settings_override_json: An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_override_yaml: An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_yaml: An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        DeploymentIntegrationsServerConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            debug_enabled=debug_enabled,
            docker_image=docker_image,
            user_settings_json=user_settings_json,
            user_settings_override_json=user_settings_override_json,
            user_settings_override_yaml=user_settings_override_yaml,
            user_settings_yaml=user_settings_yaml,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             debug_enabled: Optional[bool] = None,
             docker_image: Optional[str] = None,
             user_settings_json: Optional[str] = None,
             user_settings_override_json: Optional[str] = None,
             user_settings_override_yaml: Optional[str] = None,
             user_settings_yaml: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if debug_enabled is None and 'debugEnabled' in kwargs:
            debug_enabled = kwargs['debugEnabled']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if user_settings_json is None and 'userSettingsJson' in kwargs:
            user_settings_json = kwargs['userSettingsJson']
        if user_settings_override_json is None and 'userSettingsOverrideJson' in kwargs:
            user_settings_override_json = kwargs['userSettingsOverrideJson']
        if user_settings_override_yaml is None and 'userSettingsOverrideYaml' in kwargs:
            user_settings_override_yaml = kwargs['userSettingsOverrideYaml']
        if user_settings_yaml is None and 'userSettingsYaml' in kwargs:
            user_settings_yaml = kwargs['userSettingsYaml']

        if debug_enabled is not None:
            _setter("debug_enabled", debug_enabled)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if user_settings_json is not None:
            _setter("user_settings_json", user_settings_json)
        if user_settings_override_json is not None:
            _setter("user_settings_override_json", user_settings_override_json)
        if user_settings_override_yaml is not None:
            _setter("user_settings_override_yaml", user_settings_override_yaml)
        if user_settings_yaml is not None:
            _setter("user_settings_yaml", user_settings_yaml)

    @property
    @pulumi.getter(name="debugEnabled")
    def debug_enabled(self) -> Optional[bool]:
        """
        Optionally enable debug mode for APM servers - defaults to false
        """
        return pulumi.get(self, "debug_enabled")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="userSettingsJson")
    def user_settings_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_json")

    @property
    @pulumi.getter(name="userSettingsOverrideJson")
    def user_settings_override_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_json")

    @property
    @pulumi.getter(name="userSettingsOverrideYaml")
    def user_settings_override_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_yaml")

    @property
    @pulumi.getter(name="userSettingsYaml")
    def user_settings_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_yaml")


@pulumi.output_type
class DeploymentIntegrationsServerEndpoints(dict):
    def __init__(__self__, *,
                 apm: str,
                 fleet: str):
        DeploymentIntegrationsServerEndpoints._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm=apm,
            fleet=fleet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm: Optional[str] = None,
             fleet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if apm is None:
            raise TypeError("Missing 'apm' argument")
        if fleet is None:
            raise TypeError("Missing 'fleet' argument")

        _setter("apm", apm)
        _setter("fleet", fleet)

    @property
    @pulumi.getter
    def apm(self) -> str:
        return pulumi.get(self, "apm")

    @property
    @pulumi.getter
    def fleet(self) -> str:
        return pulumi.get(self, "fleet")


@pulumi.output_type
class DeploymentKibana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticsearchClusterRefId":
            suggest = "elasticsearch_cluster_ref_id"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpsEndpoint":
            suggest = "https_endpoint"
        elif key == "instanceConfigurationId":
            suggest = "instance_configuration_id"
        elif key == "refId":
            suggest = "ref_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "sizeResource":
            suggest = "size_resource"
        elif key == "zoneCount":
            suggest = "zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentKibana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentKibana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentKibana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional['outputs.DeploymentKibanaConfig'] = None,
                 elasticsearch_cluster_ref_id: Optional[str] = None,
                 http_endpoint: Optional[str] = None,
                 https_endpoint: Optional[str] = None,
                 instance_configuration_id: Optional[str] = None,
                 ref_id: Optional[str] = None,
                 region: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 size: Optional[str] = None,
                 size_resource: Optional[str] = None,
                 zone_count: Optional[int] = None):
        """
        :param 'DeploymentKibanaConfigArgs' config: Optionally define the Kibana configuration options for the Kibana Server
        :param str size_resource: Optional size type, defaults to "memory".
        """
        DeploymentKibana._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            instance_configuration_id=instance_configuration_id,
            ref_id=ref_id,
            region=region,
            resource_id=resource_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional['outputs.DeploymentKibanaConfig'] = None,
             elasticsearch_cluster_ref_id: Optional[str] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             instance_configuration_id: Optional[str] = None,
             ref_id: Optional[str] = None,
             region: Optional[str] = None,
             resource_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']

        if config is not None:
            _setter("config", config)
        if elasticsearch_cluster_ref_id is not None:
            _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if https_endpoint is not None:
            _setter("https_endpoint", https_endpoint)
        if instance_configuration_id is not None:
            _setter("instance_configuration_id", instance_configuration_id)
        if ref_id is not None:
            _setter("ref_id", ref_id)
        if region is not None:
            _setter("region", region)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if size is not None:
            _setter("size", size)
        if size_resource is not None:
            _setter("size_resource", size_resource)
        if zone_count is not None:
            _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.DeploymentKibanaConfig']:
        """
        Optionally define the Kibana configuration options for the Kibana Server
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> Optional[str]:
        """
        Optional size type, defaults to "memory".
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> Optional[int]:
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class DeploymentKibanaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "userSettingsJson":
            suggest = "user_settings_json"
        elif key == "userSettingsOverrideJson":
            suggest = "user_settings_override_json"
        elif key == "userSettingsOverrideYaml":
            suggest = "user_settings_override_yaml"
        elif key == "userSettingsYaml":
            suggest = "user_settings_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentKibanaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentKibanaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentKibanaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 user_settings_json: Optional[str] = None,
                 user_settings_override_json: Optional[str] = None,
                 user_settings_override_yaml: Optional[str] = None,
                 user_settings_yaml: Optional[str] = None):
        """
        :param str docker_image: Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        :param str user_settings_json: An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        :param str user_settings_override_json: An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_override_yaml: An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        :param str user_settings_yaml: An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        DeploymentKibanaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            docker_image=docker_image,
            user_settings_json=user_settings_json,
            user_settings_override_json=user_settings_override_json,
            user_settings_override_yaml=user_settings_override_yaml,
            user_settings_yaml=user_settings_yaml,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             docker_image: Optional[str] = None,
             user_settings_json: Optional[str] = None,
             user_settings_override_json: Optional[str] = None,
             user_settings_override_yaml: Optional[str] = None,
             user_settings_yaml: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if user_settings_json is None and 'userSettingsJson' in kwargs:
            user_settings_json = kwargs['userSettingsJson']
        if user_settings_override_json is None and 'userSettingsOverrideJson' in kwargs:
            user_settings_override_json = kwargs['userSettingsOverrideJson']
        if user_settings_override_yaml is None and 'userSettingsOverrideYaml' in kwargs:
            user_settings_override_yaml = kwargs['userSettingsOverrideYaml']
        if user_settings_yaml is None and 'userSettingsYaml' in kwargs:
            user_settings_yaml = kwargs['userSettingsYaml']

        if docker_image is not None:
            _setter("docker_image", docker_image)
        if user_settings_json is not None:
            _setter("user_settings_json", user_settings_json)
        if user_settings_override_json is not None:
            _setter("user_settings_override_json", user_settings_override_json)
        if user_settings_override_yaml is not None:
            _setter("user_settings_override_yaml", user_settings_override_yaml)
        if user_settings_yaml is not None:
            _setter("user_settings_yaml", user_settings_yaml)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="userSettingsJson")
    def user_settings_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_json")

    @property
    @pulumi.getter(name="userSettingsOverrideJson")
    def user_settings_override_json(self) -> Optional[str]:
        """
        An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_json")

    @property
    @pulumi.getter(name="userSettingsOverrideYaml")
    def user_settings_override_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_override_yaml")

    @property
    @pulumi.getter(name="userSettingsYaml")
    def user_settings_yaml(self) -> Optional[str]:
        """
        An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
        """
        return pulumi.get(self, "user_settings_yaml")


@pulumi.output_type
class DeploymentObservability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"
        elif key == "refId":
            suggest = "ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentObservability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentObservability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentObservability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: str,
                 logs: Optional[bool] = None,
                 metrics: Optional[bool] = None,
                 ref_id: Optional[str] = None):
        DeploymentObservability._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deployment_id=deployment_id,
            logs=logs,
            metrics=metrics,
            ref_id=ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deployment_id: Optional[str] = None,
             logs: Optional[bool] = None,
             metrics: Optional[bool] = None,
             ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if deployment_id is None and 'deploymentId' in kwargs:
            deployment_id = kwargs['deploymentId']
        if deployment_id is None:
            raise TypeError("Missing 'deployment_id' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']

        _setter("deployment_id", deployment_id)
        if logs is not None:
            _setter("logs", logs)
        if metrics is not None:
            _setter("metrics", metrics)
        if ref_id is not None:
            _setter("ref_id", ref_id)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter
    def logs(self) -> Optional[bool]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[bool]:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[str]:
        return pulumi.get(self, "ref_id")


@pulumi.output_type
class DeploymentTrafficFilterRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureEndpointGuid":
            suggest = "azure_endpoint_guid"
        elif key == "azureEndpointName":
            suggest = "azure_endpoint_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentTrafficFilterRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentTrafficFilterRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentTrafficFilterRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_endpoint_guid: Optional[str] = None,
                 azure_endpoint_name: Optional[str] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str azure_endpoint_guid: Azure endpoint GUID. Only applicable when the ruleset type is set to `azure_private_endpoint`
        :param str azure_endpoint_name: Azure endpoint name. Only applicable when the ruleset type is set to `azure_private_endpoint`
        :param str description: Description of this individual rule
        :param str id: Computed rule ID
        :param str source: Traffic filter source: IP address, CIDR mask, or VPC endpoint ID, **only required** when the type is not `azure_private_endpoint`
        """
        DeploymentTrafficFilterRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_endpoint_guid=azure_endpoint_guid,
            azure_endpoint_name=azure_endpoint_name,
            description=description,
            id=id,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_endpoint_guid: Optional[str] = None,
             azure_endpoint_name: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if azure_endpoint_guid is None and 'azureEndpointGuid' in kwargs:
            azure_endpoint_guid = kwargs['azureEndpointGuid']
        if azure_endpoint_name is None and 'azureEndpointName' in kwargs:
            azure_endpoint_name = kwargs['azureEndpointName']

        if azure_endpoint_guid is not None:
            _setter("azure_endpoint_guid", azure_endpoint_guid)
        if azure_endpoint_name is not None:
            _setter("azure_endpoint_name", azure_endpoint_name)
        if description is not None:
            _setter("description", description)
        if id is not None:
            _setter("id", id)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="azureEndpointGuid")
    def azure_endpoint_guid(self) -> Optional[str]:
        """
        Azure endpoint GUID. Only applicable when the ruleset type is set to `azure_private_endpoint`
        """
        return pulumi.get(self, "azure_endpoint_guid")

    @property
    @pulumi.getter(name="azureEndpointName")
    def azure_endpoint_name(self) -> Optional[str]:
        """
        Azure endpoint name. Only applicable when the ruleset type is set to `azure_private_endpoint`
        """
        return pulumi.get(self, "azure_endpoint_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this individual rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Computed rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Traffic filter source: IP address, CIDR mask, or VPC endpoint ID, **only required** when the type is not `azure_private_endpoint`
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class SnapshotRepositoryGeneric(dict):
    def __init__(__self__, *,
                 settings: str,
                 type: str):
        """
        :param str settings: An arbitrary JSON object containing the repository settings.
        :param str type: Repository type
        """
        SnapshotRepositoryGeneric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            settings=settings,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             settings: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if settings is None:
            raise TypeError("Missing 'settings' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("settings", settings)
        _setter("type", type)

    @property
    @pulumi.getter
    def settings(self) -> str:
        """
        An arbitrary JSON object containing the repository settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Repository type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SnapshotRepositoryS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "pathStyleAccess":
            suggest = "path_style_access"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "serverSideEncryption":
            suggest = "server_side_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotRepositoryS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotRepositoryS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotRepositoryS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 access_key: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 path_style_access: Optional[bool] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 server_side_encryption: Optional[bool] = None):
        """
        :param str bucket: Name of the S3 bucket to use for snapshots.
        :param str access_key: An S3 access key. If set, the secret_key setting must also be specified. If unset, the client will use the instance or container role instead.
        :param str endpoint: The S3 service endpoint to connect to. This defaults to s3.amazonaws.com but the AWS documentation lists alternative S3 endpoints. If you are using an S3-compatible service then you should set this to the services endpoint.
        :param bool path_style_access: Whether to force the use of the path style access pattern. If true, the path style access pattern will be used. If false, the access pattern will be automatically determined by the AWS Java SDK (See AWS documentation for details). Defaults to false.
        :param str region: Allows specifying the signing region to use. Specifying this setting manually should not be necessary for most use cases. Generally, the SDK will correctly guess the signing region to use. It should be considered an expert level setting to support S3-compatible APIs that require v4 signatures and use a region other than the default us-east-1. Defaults to empty string which means that the SDK will try to automatically determine the correct signing region.
        :param str secret_key: An S3 secret key. If set, the access_key setting must also be specified.
        :param bool server_side_encryption: When set to true files are encrypted on server side using AES256 algorithm. Defaults to false.
        """
        SnapshotRepositoryS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            access_key=access_key,
            endpoint=endpoint,
            path_style_access=path_style_access,
            region=region,
            secret_key=secret_key,
            server_side_encryption=server_side_encryption,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: Optional[str] = None,
             access_key: Optional[str] = None,
             endpoint: Optional[str] = None,
             path_style_access: Optional[bool] = None,
             region: Optional[str] = None,
             secret_key: Optional[str] = None,
             server_side_encryption: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if bucket is None:
            raise TypeError("Missing 'bucket' argument")
        if access_key is None and 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if path_style_access is None and 'pathStyleAccess' in kwargs:
            path_style_access = kwargs['pathStyleAccess']
        if secret_key is None and 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if server_side_encryption is None and 'serverSideEncryption' in kwargs:
            server_side_encryption = kwargs['serverSideEncryption']

        _setter("bucket", bucket)
        if access_key is not None:
            _setter("access_key", access_key)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if path_style_access is not None:
            _setter("path_style_access", path_style_access)
        if region is not None:
            _setter("region", region)
        if secret_key is not None:
            _setter("secret_key", secret_key)
        if server_side_encryption is not None:
            _setter("server_side_encryption", server_side_encryption)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the S3 bucket to use for snapshots.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        An S3 access key. If set, the secret_key setting must also be specified. If unset, the client will use the instance or container role instead.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The S3 service endpoint to connect to. This defaults to s3.amazonaws.com but the AWS documentation lists alternative S3 endpoints. If you are using an S3-compatible service then you should set this to the services endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="pathStyleAccess")
    def path_style_access(self) -> Optional[bool]:
        """
        Whether to force the use of the path style access pattern. If true, the path style access pattern will be used. If false, the access pattern will be automatically determined by the AWS Java SDK (See AWS documentation for details). Defaults to false.
        """
        return pulumi.get(self, "path_style_access")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Allows specifying the signing region to use. Specifying this setting manually should not be necessary for most use cases. Generally, the SDK will correctly guess the signing region to use. It should be considered an expert level setting to support S3-compatible APIs that require v4 signatures and use a region other than the default us-east-1. Defaults to empty string which means that the SDK will try to automatically determine the correct signing region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        An S3 secret key. If set, the access_key setting must also be specified.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[bool]:
        """
        When set to true files are encrypted on server side using AES256 algorithm. Defaults to false.
        """
        return pulumi.get(self, "server_side_encryption")


@pulumi.output_type
class GetDeploymentApmResult(dict):
    def __init__(__self__, *,
                 elasticsearch_cluster_ref_id: str,
                 healthy: bool,
                 http_endpoint: str,
                 https_endpoint: str,
                 ref_id: str,
                 resource_id: str,
                 status: str,
                 topologies: Sequence['outputs.GetDeploymentApmTopologyResult'],
                 version: str):
        """
        :param str elasticsearch_cluster_ref_id: The locally-unique user-specified id of an APM Resource.
        :param bool healthy: APM resource health status.
        :param str http_endpoint: HTTP endpoint for the APM resource.
        :param str https_endpoint: HTTPS endpoint for the APM resource.
        :param str ref_id: A locally-unique friendly alias for this APM resource.
        :param str resource_id: The resource unique identifier.
        :param str status: APM resource status (for example, "started", "stopped", etc).
        :param Sequence['GetDeploymentApmTopologyArgs'] topologies: Node topology element definition.
        :param str version: Elastic stack version.
        """
        GetDeploymentApmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            healthy=healthy,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            ref_id=ref_id,
            resource_id=resource_id,
            status=status,
            topologies=topologies,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elasticsearch_cluster_ref_id: Optional[str] = None,
             healthy: Optional[bool] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             ref_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             status: Optional[str] = None,
             topologies: Optional[Sequence['outputs.GetDeploymentApmTopologyResult']] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if elasticsearch_cluster_ref_id is None:
            raise TypeError("Missing 'elasticsearch_cluster_ref_id' argument")
        if healthy is None:
            raise TypeError("Missing 'healthy' argument")
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if https_endpoint is None:
            raise TypeError("Missing 'https_endpoint' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if ref_id is None:
            raise TypeError("Missing 'ref_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if topologies is None:
            raise TypeError("Missing 'topologies' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        _setter("healthy", healthy)
        _setter("http_endpoint", http_endpoint)
        _setter("https_endpoint", https_endpoint)
        _setter("ref_id", ref_id)
        _setter("resource_id", resource_id)
        _setter("status", status)
        _setter("topologies", topologies)
        _setter("version", version)

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> str:
        """
        The locally-unique user-specified id of an APM Resource.
        """
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        APM resource health status.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        HTTP endpoint for the APM resource.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> str:
        """
        HTTPS endpoint for the APM resource.
        """
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        A locally-unique friendly alias for this APM resource.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource unique identifier.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        APM resource status (for example, "started", "stopped", etc).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def topologies(self) -> Sequence['outputs.GetDeploymentApmTopologyResult']:
        """
        Node topology element definition.
        """
        return pulumi.get(self, "topologies")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentApmTopologyResult(dict):
    def __init__(__self__, *,
                 instance_configuration_id: str,
                 size: str,
                 size_resource: str,
                 zone_count: int):
        """
        :param str instance_configuration_id: Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        :param str size: Amount of "size_resource" in Gigabytes. For example "4g".
        :param str size_resource: Type of resource ("memory" or "storage")
        :param int zone_count: Number of zones in which nodes will be placed.
        """
        GetDeploymentApmTopologyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_configuration_id=instance_configuration_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_configuration_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if instance_configuration_id is None:
            raise TypeError("Missing 'instance_configuration_id' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if size_resource is None:
            raise TypeError("Missing 'size_resource' argument")
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']
        if zone_count is None:
            raise TypeError("Missing 'zone_count' argument")

        _setter("instance_configuration_id", instance_configuration_id)
        _setter("size", size)
        _setter("size_resource", size_resource)
        _setter("zone_count", zone_count)

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> str:
        """
        Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        """
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Amount of "size_resource" in Gigabytes. For example "4g".
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> str:
        """
        Type of resource ("memory" or "storage")
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> int:
        """
        Number of zones in which nodes will be placed.
        """
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class GetDeploymentElasticsearchResult(dict):
    def __init__(__self__, *,
                 autoscale: str,
                 cloud_id: str,
                 healthy: bool,
                 http_endpoint: str,
                 https_endpoint: str,
                 ref_id: str,
                 resource_id: str,
                 status: str,
                 topologies: Sequence['outputs.GetDeploymentElasticsearchTopologyResult'],
                 version: str):
        """
        :param str autoscale: Whether or not Elasticsearch autoscaling is enabled.
        :param str cloud_id: The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana. See [Configure Beats and Logstash with Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html) for more information.
        :param bool healthy: Elasticsearch resource health status.
        :param str http_endpoint: HTTP endpoint for the Elasticsearch resource.
        :param str https_endpoint: HTTPS endpoint for the Elasticsearch resource.
        :param str ref_id: A locally-unique friendly alias for this Elasticsearch cluster.
        :param str resource_id: The resource unique identifier.
        :param str status: Elasticsearch resource status (for example, "started", "stopped", etc).
        :param Sequence['GetDeploymentElasticsearchTopologyArgs'] topologies: Node topology element definition.
        :param str version: Elastic stack version.
        """
        GetDeploymentElasticsearchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscale=autoscale,
            cloud_id=cloud_id,
            healthy=healthy,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            ref_id=ref_id,
            resource_id=resource_id,
            status=status,
            topologies=topologies,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscale: Optional[str] = None,
             cloud_id: Optional[str] = None,
             healthy: Optional[bool] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             ref_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             status: Optional[str] = None,
             topologies: Optional[Sequence['outputs.GetDeploymentElasticsearchTopologyResult']] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscale is None:
            raise TypeError("Missing 'autoscale' argument")
        if cloud_id is None and 'cloudId' in kwargs:
            cloud_id = kwargs['cloudId']
        if cloud_id is None:
            raise TypeError("Missing 'cloud_id' argument")
        if healthy is None:
            raise TypeError("Missing 'healthy' argument")
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if https_endpoint is None:
            raise TypeError("Missing 'https_endpoint' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if ref_id is None:
            raise TypeError("Missing 'ref_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if topologies is None:
            raise TypeError("Missing 'topologies' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("autoscale", autoscale)
        _setter("cloud_id", cloud_id)
        _setter("healthy", healthy)
        _setter("http_endpoint", http_endpoint)
        _setter("https_endpoint", https_endpoint)
        _setter("ref_id", ref_id)
        _setter("resource_id", resource_id)
        _setter("status", status)
        _setter("topologies", topologies)
        _setter("version", version)

    @property
    @pulumi.getter
    def autoscale(self) -> str:
        """
        Whether or not Elasticsearch autoscaling is enabled.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> str:
        """
        The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana. See [Configure Beats and Logstash with Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html) for more information.
        """
        return pulumi.get(self, "cloud_id")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        Elasticsearch resource health status.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        HTTP endpoint for the Elasticsearch resource.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> str:
        """
        HTTPS endpoint for the Elasticsearch resource.
        """
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        A locally-unique friendly alias for this Elasticsearch cluster.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource unique identifier.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Elasticsearch resource status (for example, "started", "stopped", etc).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def topologies(self) -> Sequence['outputs.GetDeploymentElasticsearchTopologyResult']:
        """
        Node topology element definition.
        """
        return pulumi.get(self, "topologies")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentElasticsearchTopologyResult(dict):
    def __init__(__self__, *,
                 autoscalings: Sequence['outputs.GetDeploymentElasticsearchTopologyAutoscalingResult'],
                 instance_configuration_id: str,
                 node_roles: Sequence[str],
                 node_type_data: bool,
                 node_type_ingest: bool,
                 node_type_master: bool,
                 node_type_ml: bool,
                 size: str,
                 size_resource: str,
                 zone_count: int):
        """
        :param Sequence['GetDeploymentElasticsearchTopologyAutoscalingArgs'] autoscalings: Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        :param str instance_configuration_id: Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        :param Sequence[str] node_roles: Defines the list of Elasticsearch node roles assigned to the topology element. This is supported from v7.10, and required from v8.
        :param bool node_type_data: Defines whether this node can hold data (\\n\\n).
        :param bool node_type_ingest: Defines whether this node can run an ingest pipeline (\\n\\n).
        :param bool node_type_master: Defines whether this node can be elected master (\\n\\n).
        :param bool node_type_ml: Defines whether this node can run ML jobs (\\n\\n).
        :param str size: Amount of "size_resource" in Gigabytes. For example "4g".
        :param str size_resource: Type of resource ("memory" or "storage")
        :param int zone_count: Number of zones in which nodes will be placed.
        """
        GetDeploymentElasticsearchTopologyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscalings=autoscalings,
            instance_configuration_id=instance_configuration_id,
            node_roles=node_roles,
            node_type_data=node_type_data,
            node_type_ingest=node_type_ingest,
            node_type_master=node_type_master,
            node_type_ml=node_type_ml,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscalings: Optional[Sequence['outputs.GetDeploymentElasticsearchTopologyAutoscalingResult']] = None,
             instance_configuration_id: Optional[str] = None,
             node_roles: Optional[Sequence[str]] = None,
             node_type_data: Optional[bool] = None,
             node_type_ingest: Optional[bool] = None,
             node_type_master: Optional[bool] = None,
             node_type_ml: Optional[bool] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if autoscalings is None:
            raise TypeError("Missing 'autoscalings' argument")
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if instance_configuration_id is None:
            raise TypeError("Missing 'instance_configuration_id' argument")
        if node_roles is None and 'nodeRoles' in kwargs:
            node_roles = kwargs['nodeRoles']
        if node_roles is None:
            raise TypeError("Missing 'node_roles' argument")
        if node_type_data is None and 'nodeTypeData' in kwargs:
            node_type_data = kwargs['nodeTypeData']
        if node_type_data is None:
            raise TypeError("Missing 'node_type_data' argument")
        if node_type_ingest is None and 'nodeTypeIngest' in kwargs:
            node_type_ingest = kwargs['nodeTypeIngest']
        if node_type_ingest is None:
            raise TypeError("Missing 'node_type_ingest' argument")
        if node_type_master is None and 'nodeTypeMaster' in kwargs:
            node_type_master = kwargs['nodeTypeMaster']
        if node_type_master is None:
            raise TypeError("Missing 'node_type_master' argument")
        if node_type_ml is None and 'nodeTypeMl' in kwargs:
            node_type_ml = kwargs['nodeTypeMl']
        if node_type_ml is None:
            raise TypeError("Missing 'node_type_ml' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if size_resource is None:
            raise TypeError("Missing 'size_resource' argument")
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']
        if zone_count is None:
            raise TypeError("Missing 'zone_count' argument")

        _setter("autoscalings", autoscalings)
        _setter("instance_configuration_id", instance_configuration_id)
        _setter("node_roles", node_roles)
        _setter("node_type_data", node_type_data)
        _setter("node_type_ingest", node_type_ingest)
        _setter("node_type_master", node_type_master)
        _setter("node_type_ml", node_type_ml)
        _setter("size", size)
        _setter("size_resource", size_resource)
        _setter("zone_count", zone_count)

    @property
    @pulumi.getter
    def autoscalings(self) -> Sequence['outputs.GetDeploymentElasticsearchTopologyAutoscalingResult']:
        """
        Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
        """
        return pulumi.get(self, "autoscalings")

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> str:
        """
        Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        """
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeRoles")
    def node_roles(self) -> Sequence[str]:
        """
        Defines the list of Elasticsearch node roles assigned to the topology element. This is supported from v7.10, and required from v8.
        """
        return pulumi.get(self, "node_roles")

    @property
    @pulumi.getter(name="nodeTypeData")
    def node_type_data(self) -> bool:
        """
        Defines whether this node can hold data (\\n\\n).
        """
        return pulumi.get(self, "node_type_data")

    @property
    @pulumi.getter(name="nodeTypeIngest")
    def node_type_ingest(self) -> bool:
        """
        Defines whether this node can run an ingest pipeline (\\n\\n).
        """
        return pulumi.get(self, "node_type_ingest")

    @property
    @pulumi.getter(name="nodeTypeMaster")
    def node_type_master(self) -> bool:
        """
        Defines whether this node can be elected master (\\n\\n).
        """
        return pulumi.get(self, "node_type_master")

    @property
    @pulumi.getter(name="nodeTypeMl")
    def node_type_ml(self) -> bool:
        """
        Defines whether this node can run ML jobs (\\n\\n).
        """
        return pulumi.get(self, "node_type_ml")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Amount of "size_resource" in Gigabytes. For example "4g".
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> str:
        """
        Type of resource ("memory" or "storage")
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> int:
        """
        Number of zones in which nodes will be placed.
        """
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class GetDeploymentElasticsearchTopologyAutoscalingResult(dict):
    def __init__(__self__, *,
                 max_size: str,
                 max_size_resource: str,
                 min_size: str,
                 min_size_resource: str,
                 policy_override_json: str):
        """
        :param str max_size: Maximum size the tier can scale up to, e.g "64g".
        :param str max_size_resource: Resource type used when specifying the maximum size the tier can scale up to.
        :param str min_size: Minimum size the tier can scale down to when bidirectional autoscaling is supported.
        :param str min_size_resource: Resource type used when specifying the minimum size the tier can scale down to when bidirectional autoscaling is supported.
        :param str policy_override_json: An arbitrary JSON object overriding the default autoscaling policy. Don't set unless you really know what you are doing.
        """
        GetDeploymentElasticsearchTopologyAutoscalingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            max_size_resource=max_size_resource,
            min_size=min_size,
            min_size_resource=min_size_resource,
            policy_override_json=policy_override_json,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[str] = None,
             max_size_resource: Optional[str] = None,
             min_size: Optional[str] = None,
             min_size_resource: Optional[str] = None,
             policy_override_json: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size is None:
            raise TypeError("Missing 'max_size' argument")
        if max_size_resource is None and 'maxSizeResource' in kwargs:
            max_size_resource = kwargs['maxSizeResource']
        if max_size_resource is None:
            raise TypeError("Missing 'max_size_resource' argument")
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size is None:
            raise TypeError("Missing 'min_size' argument")
        if min_size_resource is None and 'minSizeResource' in kwargs:
            min_size_resource = kwargs['minSizeResource']
        if min_size_resource is None:
            raise TypeError("Missing 'min_size_resource' argument")
        if policy_override_json is None and 'policyOverrideJson' in kwargs:
            policy_override_json = kwargs['policyOverrideJson']
        if policy_override_json is None:
            raise TypeError("Missing 'policy_override_json' argument")

        _setter("max_size", max_size)
        _setter("max_size_resource", max_size_resource)
        _setter("min_size", min_size)
        _setter("min_size_resource", min_size_resource)
        _setter("policy_override_json", policy_override_json)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> str:
        """
        Maximum size the tier can scale up to, e.g "64g".
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="maxSizeResource")
    def max_size_resource(self) -> str:
        """
        Resource type used when specifying the maximum size the tier can scale up to.
        """
        return pulumi.get(self, "max_size_resource")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> str:
        """
        Minimum size the tier can scale down to when bidirectional autoscaling is supported.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="minSizeResource")
    def min_size_resource(self) -> str:
        """
        Resource type used when specifying the minimum size the tier can scale down to when bidirectional autoscaling is supported.
        """
        return pulumi.get(self, "min_size_resource")

    @property
    @pulumi.getter(name="policyOverrideJson")
    def policy_override_json(self) -> str:
        """
        An arbitrary JSON object overriding the default autoscaling policy. Don't set unless you really know what you are doing.
        """
        return pulumi.get(self, "policy_override_json")


@pulumi.output_type
class GetDeploymentEnterpriseSearchResult(dict):
    def __init__(__self__, *,
                 elasticsearch_cluster_ref_id: str,
                 healthy: bool,
                 http_endpoint: str,
                 https_endpoint: str,
                 ref_id: str,
                 resource_id: str,
                 status: str,
                 topologies: Sequence['outputs.GetDeploymentEnterpriseSearchTopologyResult'],
                 version: str):
        """
        :param str elasticsearch_cluster_ref_id: A locally-unique friendly alias for an Elasticsearch resource in this deployment.
        :param bool healthy: Enterprise Search resource health status.
        :param str http_endpoint: HTTP endpoint for the Enterprise Search resource.
        :param str https_endpoint: HTTPS endpoint for the Enterprise Search resource.
        :param str ref_id: A locally-unique friendly alias for this Enterprise Search resource.
        :param str resource_id: The resource unique identifier.
        :param str status: Enterprise Search resource status (for example, "started", "stopped", etc).
        :param Sequence['GetDeploymentEnterpriseSearchTopologyArgs'] topologies: Node topology element definition.
        :param str version: Elastic stack version.
        """
        GetDeploymentEnterpriseSearchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            healthy=healthy,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            ref_id=ref_id,
            resource_id=resource_id,
            status=status,
            topologies=topologies,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elasticsearch_cluster_ref_id: Optional[str] = None,
             healthy: Optional[bool] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             ref_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             status: Optional[str] = None,
             topologies: Optional[Sequence['outputs.GetDeploymentEnterpriseSearchTopologyResult']] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if elasticsearch_cluster_ref_id is None:
            raise TypeError("Missing 'elasticsearch_cluster_ref_id' argument")
        if healthy is None:
            raise TypeError("Missing 'healthy' argument")
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if https_endpoint is None:
            raise TypeError("Missing 'https_endpoint' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if ref_id is None:
            raise TypeError("Missing 'ref_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if topologies is None:
            raise TypeError("Missing 'topologies' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        _setter("healthy", healthy)
        _setter("http_endpoint", http_endpoint)
        _setter("https_endpoint", https_endpoint)
        _setter("ref_id", ref_id)
        _setter("resource_id", resource_id)
        _setter("status", status)
        _setter("topologies", topologies)
        _setter("version", version)

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> str:
        """
        A locally-unique friendly alias for an Elasticsearch resource in this deployment.
        """
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        Enterprise Search resource health status.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        HTTP endpoint for the Enterprise Search resource.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> str:
        """
        HTTPS endpoint for the Enterprise Search resource.
        """
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        A locally-unique friendly alias for this Enterprise Search resource.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource unique identifier.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enterprise Search resource status (for example, "started", "stopped", etc).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def topologies(self) -> Sequence['outputs.GetDeploymentEnterpriseSearchTopologyResult']:
        """
        Node topology element definition.
        """
        return pulumi.get(self, "topologies")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentEnterpriseSearchTopologyResult(dict):
    def __init__(__self__, *,
                 instance_configuration_id: str,
                 node_type_appserver: bool,
                 node_type_connector: bool,
                 node_type_worker: bool,
                 size: str,
                 size_resource: str,
                 zone_count: int):
        """
        :param str instance_configuration_id: Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        :param bool node_type_appserver: Defines whether this instance should run as application/API server.
        :param bool node_type_connector: Defines whether this instance should run as connector.
        :param bool node_type_worker: Defines whether this instance should run as background worker.
        :param str size: Amount of "size_resource" in Gigabytes. For example "4g".
        :param str size_resource: Type of resource ("memory" or "storage")
        :param int zone_count: Number of zones in which nodes will be placed.
        """
        GetDeploymentEnterpriseSearchTopologyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_configuration_id=instance_configuration_id,
            node_type_appserver=node_type_appserver,
            node_type_connector=node_type_connector,
            node_type_worker=node_type_worker,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_configuration_id: Optional[str] = None,
             node_type_appserver: Optional[bool] = None,
             node_type_connector: Optional[bool] = None,
             node_type_worker: Optional[bool] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if instance_configuration_id is None:
            raise TypeError("Missing 'instance_configuration_id' argument")
        if node_type_appserver is None and 'nodeTypeAppserver' in kwargs:
            node_type_appserver = kwargs['nodeTypeAppserver']
        if node_type_appserver is None:
            raise TypeError("Missing 'node_type_appserver' argument")
        if node_type_connector is None and 'nodeTypeConnector' in kwargs:
            node_type_connector = kwargs['nodeTypeConnector']
        if node_type_connector is None:
            raise TypeError("Missing 'node_type_connector' argument")
        if node_type_worker is None and 'nodeTypeWorker' in kwargs:
            node_type_worker = kwargs['nodeTypeWorker']
        if node_type_worker is None:
            raise TypeError("Missing 'node_type_worker' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if size_resource is None:
            raise TypeError("Missing 'size_resource' argument")
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']
        if zone_count is None:
            raise TypeError("Missing 'zone_count' argument")

        _setter("instance_configuration_id", instance_configuration_id)
        _setter("node_type_appserver", node_type_appserver)
        _setter("node_type_connector", node_type_connector)
        _setter("node_type_worker", node_type_worker)
        _setter("size", size)
        _setter("size_resource", size_resource)
        _setter("zone_count", zone_count)

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> str:
        """
        Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        """
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter(name="nodeTypeAppserver")
    def node_type_appserver(self) -> bool:
        """
        Defines whether this instance should run as application/API server.
        """
        return pulumi.get(self, "node_type_appserver")

    @property
    @pulumi.getter(name="nodeTypeConnector")
    def node_type_connector(self) -> bool:
        """
        Defines whether this instance should run as connector.
        """
        return pulumi.get(self, "node_type_connector")

    @property
    @pulumi.getter(name="nodeTypeWorker")
    def node_type_worker(self) -> bool:
        """
        Defines whether this instance should run as background worker.
        """
        return pulumi.get(self, "node_type_worker")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Amount of "size_resource" in Gigabytes. For example "4g".
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> str:
        """
        Type of resource ("memory" or "storage")
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> int:
        """
        Number of zones in which nodes will be placed.
        """
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class GetDeploymentIntegrationsServerResult(dict):
    def __init__(__self__, *,
                 elasticsearch_cluster_ref_id: str,
                 healthy: bool,
                 http_endpoint: str,
                 https_endpoint: str,
                 ref_id: str,
                 resource_id: str,
                 status: str,
                 topologies: Sequence['outputs.GetDeploymentIntegrationsServerTopologyResult'],
                 version: str):
        """
        :param str elasticsearch_cluster_ref_id: A locally-unique friendly alias for an Elasticsearch resource in this deployment.
        :param bool healthy: Resource kind health status.
        :param str http_endpoint: HTTP endpoint for the resource kind.
        :param str https_endpoint: HTTPS endpoint for the resource kind.
        :param str ref_id: A locally-unique friendly alias for this Integrations Server resource.
        :param str resource_id: The resource unique identifier.
        :param str status: Resource kind status (for example, "started", "stopped", etc).
        :param Sequence['GetDeploymentIntegrationsServerTopologyArgs'] topologies: Node topology element definition.
        :param str version: Elastic stack version.
        """
        GetDeploymentIntegrationsServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            healthy=healthy,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            ref_id=ref_id,
            resource_id=resource_id,
            status=status,
            topologies=topologies,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elasticsearch_cluster_ref_id: Optional[str] = None,
             healthy: Optional[bool] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             ref_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             status: Optional[str] = None,
             topologies: Optional[Sequence['outputs.GetDeploymentIntegrationsServerTopologyResult']] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if elasticsearch_cluster_ref_id is None:
            raise TypeError("Missing 'elasticsearch_cluster_ref_id' argument")
        if healthy is None:
            raise TypeError("Missing 'healthy' argument")
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if https_endpoint is None:
            raise TypeError("Missing 'https_endpoint' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if ref_id is None:
            raise TypeError("Missing 'ref_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if topologies is None:
            raise TypeError("Missing 'topologies' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        _setter("healthy", healthy)
        _setter("http_endpoint", http_endpoint)
        _setter("https_endpoint", https_endpoint)
        _setter("ref_id", ref_id)
        _setter("resource_id", resource_id)
        _setter("status", status)
        _setter("topologies", topologies)
        _setter("version", version)

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> str:
        """
        A locally-unique friendly alias for an Elasticsearch resource in this deployment.
        """
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        Resource kind health status.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        HTTP endpoint for the resource kind.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> str:
        """
        HTTPS endpoint for the resource kind.
        """
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        A locally-unique friendly alias for this Integrations Server resource.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource unique identifier.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Resource kind status (for example, "started", "stopped", etc).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def topologies(self) -> Sequence['outputs.GetDeploymentIntegrationsServerTopologyResult']:
        """
        Node topology element definition.
        """
        return pulumi.get(self, "topologies")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentIntegrationsServerTopologyResult(dict):
    def __init__(__self__, *,
                 instance_configuration_id: str,
                 size: str,
                 size_resource: str,
                 zone_count: int):
        """
        :param str instance_configuration_id: Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        :param str size: Amount of "size_resource" in Gigabytes. For example "4g".
        :param str size_resource: Type of resource ("memory" or "storage")
        :param int zone_count: Number of zones in which nodes will be placed.
        """
        GetDeploymentIntegrationsServerTopologyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_configuration_id=instance_configuration_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_configuration_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if instance_configuration_id is None:
            raise TypeError("Missing 'instance_configuration_id' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if size_resource is None:
            raise TypeError("Missing 'size_resource' argument")
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']
        if zone_count is None:
            raise TypeError("Missing 'zone_count' argument")

        _setter("instance_configuration_id", instance_configuration_id)
        _setter("size", size)
        _setter("size_resource", size_resource)
        _setter("zone_count", zone_count)

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> str:
        """
        Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        """
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Amount of "size_resource" in Gigabytes. For example "4g".
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> str:
        """
        Type of resource ("memory" or "storage")
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> int:
        """
        Number of zones in which nodes will be placed.
        """
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class GetDeploymentKibanaResult(dict):
    def __init__(__self__, *,
                 elasticsearch_cluster_ref_id: str,
                 healthy: bool,
                 http_endpoint: str,
                 https_endpoint: str,
                 ref_id: str,
                 resource_id: str,
                 status: str,
                 topologies: Sequence['outputs.GetDeploymentKibanaTopologyResult'],
                 version: str):
        """
        :param str elasticsearch_cluster_ref_id: A locally-unique friendly alias for an Elasticsearch resource in this deployment.
        :param bool healthy: Kibana resource health status.
        :param str http_endpoint: HTTP endpoint for the Kibana resource.
        :param str https_endpoint: HTTPS endpoint for the Kibana resource.
        :param str ref_id: A locally-unique friendly alias for this Kibana resource.
        :param str resource_id: The resource unique identifier.
        :param str status: Kibana resource status (for example, "started", "stopped", etc).
        :param Sequence['GetDeploymentKibanaTopologyArgs'] topologies: Node topology element definition.
        :param str version: Elastic stack version.
        """
        GetDeploymentKibanaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elasticsearch_cluster_ref_id=elasticsearch_cluster_ref_id,
            healthy=healthy,
            http_endpoint=http_endpoint,
            https_endpoint=https_endpoint,
            ref_id=ref_id,
            resource_id=resource_id,
            status=status,
            topologies=topologies,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elasticsearch_cluster_ref_id: Optional[str] = None,
             healthy: Optional[bool] = None,
             http_endpoint: Optional[str] = None,
             https_endpoint: Optional[str] = None,
             ref_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             status: Optional[str] = None,
             topologies: Optional[Sequence['outputs.GetDeploymentKibanaTopologyResult']] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if elasticsearch_cluster_ref_id is None and 'elasticsearchClusterRefId' in kwargs:
            elasticsearch_cluster_ref_id = kwargs['elasticsearchClusterRefId']
        if elasticsearch_cluster_ref_id is None:
            raise TypeError("Missing 'elasticsearch_cluster_ref_id' argument")
        if healthy is None:
            raise TypeError("Missing 'healthy' argument")
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if https_endpoint is None and 'httpsEndpoint' in kwargs:
            https_endpoint = kwargs['httpsEndpoint']
        if https_endpoint is None:
            raise TypeError("Missing 'https_endpoint' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if ref_id is None:
            raise TypeError("Missing 'ref_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if topologies is None:
            raise TypeError("Missing 'topologies' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("elasticsearch_cluster_ref_id", elasticsearch_cluster_ref_id)
        _setter("healthy", healthy)
        _setter("http_endpoint", http_endpoint)
        _setter("https_endpoint", https_endpoint)
        _setter("ref_id", ref_id)
        _setter("resource_id", resource_id)
        _setter("status", status)
        _setter("topologies", topologies)
        _setter("version", version)

    @property
    @pulumi.getter(name="elasticsearchClusterRefId")
    def elasticsearch_cluster_ref_id(self) -> str:
        """
        A locally-unique friendly alias for an Elasticsearch resource in this deployment.
        """
        return pulumi.get(self, "elasticsearch_cluster_ref_id")

    @property
    @pulumi.getter
    def healthy(self) -> bool:
        """
        Kibana resource health status.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        HTTP endpoint for the Kibana resource.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpsEndpoint")
    def https_endpoint(self) -> str:
        """
        HTTPS endpoint for the Kibana resource.
        """
        return pulumi.get(self, "https_endpoint")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        A locally-unique friendly alias for this Kibana resource.
        """
        return pulumi.get(self, "ref_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource unique identifier.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Kibana resource status (for example, "started", "stopped", etc).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def topologies(self) -> Sequence['outputs.GetDeploymentKibanaTopologyResult']:
        """
        Node topology element definition.
        """
        return pulumi.get(self, "topologies")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentKibanaTopologyResult(dict):
    def __init__(__self__, *,
                 instance_configuration_id: str,
                 size: str,
                 size_resource: str,
                 zone_count: int):
        """
        :param str instance_configuration_id: Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        :param str size: Amount of "size_resource" in Gigabytes. For example "4g".
        :param str size_resource: Type of resource ("memory" or "storage")
        :param int zone_count: Number of zones in which nodes will be placed.
        """
        GetDeploymentKibanaTopologyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_configuration_id=instance_configuration_id,
            size=size,
            size_resource=size_resource,
            zone_count=zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_configuration_id: Optional[str] = None,
             size: Optional[str] = None,
             size_resource: Optional[str] = None,
             zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_configuration_id is None and 'instanceConfigurationId' in kwargs:
            instance_configuration_id = kwargs['instanceConfigurationId']
        if instance_configuration_id is None:
            raise TypeError("Missing 'instance_configuration_id' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if size_resource is None and 'sizeResource' in kwargs:
            size_resource = kwargs['sizeResource']
        if size_resource is None:
            raise TypeError("Missing 'size_resource' argument")
        if zone_count is None and 'zoneCount' in kwargs:
            zone_count = kwargs['zoneCount']
        if zone_count is None:
            raise TypeError("Missing 'zone_count' argument")

        _setter("instance_configuration_id", instance_configuration_id)
        _setter("size", size)
        _setter("size_resource", size_resource)
        _setter("zone_count", zone_count)

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> str:
        """
        Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
        """
        return pulumi.get(self, "instance_configuration_id")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Amount of "size_resource" in Gigabytes. For example "4g".
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeResource")
    def size_resource(self) -> str:
        """
        Type of resource ("memory" or "storage")
        """
        return pulumi.get(self, "size_resource")

    @property
    @pulumi.getter(name="zoneCount")
    def zone_count(self) -> int:
        """
        Number of zones in which nodes will be placed.
        """
        return pulumi.get(self, "zone_count")


@pulumi.output_type
class GetDeploymentObservabilityResult(dict):
    def __init__(__self__, *,
                 deployment_id: str,
                 logs: bool,
                 metrics: bool,
                 ref_id: str):
        """
        :param str deployment_id: Destination deployment ID for the shipped logs and monitoring metrics.
        :param bool logs: Defines whether logs are shipped to the destination deployment.
        :param bool metrics: Defines whether metrics are shipped to the destination deployment.
        :param str ref_id: Elasticsearch resource kind ref_id of the destination deployment.
        """
        GetDeploymentObservabilityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deployment_id=deployment_id,
            logs=logs,
            metrics=metrics,
            ref_id=ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deployment_id: Optional[str] = None,
             logs: Optional[bool] = None,
             metrics: Optional[bool] = None,
             ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if deployment_id is None and 'deploymentId' in kwargs:
            deployment_id = kwargs['deploymentId']
        if deployment_id is None:
            raise TypeError("Missing 'deployment_id' argument")
        if logs is None:
            raise TypeError("Missing 'logs' argument")
        if metrics is None:
            raise TypeError("Missing 'metrics' argument")
        if ref_id is None and 'refId' in kwargs:
            ref_id = kwargs['refId']
        if ref_id is None:
            raise TypeError("Missing 'ref_id' argument")

        _setter("deployment_id", deployment_id)
        _setter("logs", logs)
        _setter("metrics", metrics)
        _setter("ref_id", ref_id)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        """
        Destination deployment ID for the shipped logs and monitoring metrics.
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter
    def logs(self) -> bool:
        """
        Defines whether logs are shipped to the destination deployment.
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> bool:
        """
        Defines whether metrics are shipped to the destination deployment.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> str:
        """
        Elasticsearch resource kind ref_id of the destination deployment.
        """
        return pulumi.get(self, "ref_id")


@pulumi.output_type
class GetDeploymentsApmResult(dict):
    def __init__(__self__, *,
                 healthy: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str healthy: Overall health status of the resource instances.
        :param str status: Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        :param str version: Elastic stack version.
        """
        GetDeploymentsApmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy=healthy,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy: Optional[str] = None,
             status: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if healthy is not None:
            _setter("healthy", healthy)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[str]:
        """
        Overall health status of the resource instances.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentsDeploymentResult(dict):
    def __init__(__self__, *,
                 alias: str,
                 apm_ref_id: str,
                 apm_resource_id: str,
                 deployment_id: str,
                 elasticsearch_ref_id: str,
                 elasticsearch_resource_id: str,
                 enterprise_search_ref_id: str,
                 enterprise_search_resource_id: str,
                 integrations_server_ref_id: str,
                 integrations_server_resource_id: str,
                 kibana_ref_id: str,
                 kibana_resource_id: str,
                 name: str):
        """
        :param str alias: Deployment alias.
        :param str apm_ref_id: The APM resource reference.
        :param str apm_resource_id: The APM resource unique ID.
        :param str deployment_id: The deployment unique ID.
        :param str elasticsearch_ref_id: The Elasticsearch resource reference.
        :param str elasticsearch_resource_id: The Elasticsearch resource unique ID.
        :param str enterprise_search_ref_id: The Enterprise Search resource reference.
        :param str enterprise_search_resource_id: The Enterprise Search resource unique ID.
        :param str integrations_server_ref_id: The Integrations Server resource reference.
        :param str integrations_server_resource_id: The Integrations Server resource unique ID.
        :param str kibana_ref_id: The Kibana resource reference.
        :param str kibana_resource_id: The Kibana resource unique ID.
        :param str name: The name of the deployment.
        """
        GetDeploymentsDeploymentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            apm_ref_id=apm_ref_id,
            apm_resource_id=apm_resource_id,
            deployment_id=deployment_id,
            elasticsearch_ref_id=elasticsearch_ref_id,
            elasticsearch_resource_id=elasticsearch_resource_id,
            enterprise_search_ref_id=enterprise_search_ref_id,
            enterprise_search_resource_id=enterprise_search_resource_id,
            integrations_server_ref_id=integrations_server_ref_id,
            integrations_server_resource_id=integrations_server_resource_id,
            kibana_ref_id=kibana_ref_id,
            kibana_resource_id=kibana_resource_id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             apm_ref_id: Optional[str] = None,
             apm_resource_id: Optional[str] = None,
             deployment_id: Optional[str] = None,
             elasticsearch_ref_id: Optional[str] = None,
             elasticsearch_resource_id: Optional[str] = None,
             enterprise_search_ref_id: Optional[str] = None,
             enterprise_search_resource_id: Optional[str] = None,
             integrations_server_ref_id: Optional[str] = None,
             integrations_server_resource_id: Optional[str] = None,
             kibana_ref_id: Optional[str] = None,
             kibana_resource_id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if apm_ref_id is None and 'apmRefId' in kwargs:
            apm_ref_id = kwargs['apmRefId']
        if apm_ref_id is None:
            raise TypeError("Missing 'apm_ref_id' argument")
        if apm_resource_id is None and 'apmResourceId' in kwargs:
            apm_resource_id = kwargs['apmResourceId']
        if apm_resource_id is None:
            raise TypeError("Missing 'apm_resource_id' argument")
        if deployment_id is None and 'deploymentId' in kwargs:
            deployment_id = kwargs['deploymentId']
        if deployment_id is None:
            raise TypeError("Missing 'deployment_id' argument")
        if elasticsearch_ref_id is None and 'elasticsearchRefId' in kwargs:
            elasticsearch_ref_id = kwargs['elasticsearchRefId']
        if elasticsearch_ref_id is None:
            raise TypeError("Missing 'elasticsearch_ref_id' argument")
        if elasticsearch_resource_id is None and 'elasticsearchResourceId' in kwargs:
            elasticsearch_resource_id = kwargs['elasticsearchResourceId']
        if elasticsearch_resource_id is None:
            raise TypeError("Missing 'elasticsearch_resource_id' argument")
        if enterprise_search_ref_id is None and 'enterpriseSearchRefId' in kwargs:
            enterprise_search_ref_id = kwargs['enterpriseSearchRefId']
        if enterprise_search_ref_id is None:
            raise TypeError("Missing 'enterprise_search_ref_id' argument")
        if enterprise_search_resource_id is None and 'enterpriseSearchResourceId' in kwargs:
            enterprise_search_resource_id = kwargs['enterpriseSearchResourceId']
        if enterprise_search_resource_id is None:
            raise TypeError("Missing 'enterprise_search_resource_id' argument")
        if integrations_server_ref_id is None and 'integrationsServerRefId' in kwargs:
            integrations_server_ref_id = kwargs['integrationsServerRefId']
        if integrations_server_ref_id is None:
            raise TypeError("Missing 'integrations_server_ref_id' argument")
        if integrations_server_resource_id is None and 'integrationsServerResourceId' in kwargs:
            integrations_server_resource_id = kwargs['integrationsServerResourceId']
        if integrations_server_resource_id is None:
            raise TypeError("Missing 'integrations_server_resource_id' argument")
        if kibana_ref_id is None and 'kibanaRefId' in kwargs:
            kibana_ref_id = kwargs['kibanaRefId']
        if kibana_ref_id is None:
            raise TypeError("Missing 'kibana_ref_id' argument")
        if kibana_resource_id is None and 'kibanaResourceId' in kwargs:
            kibana_resource_id = kwargs['kibanaResourceId']
        if kibana_resource_id is None:
            raise TypeError("Missing 'kibana_resource_id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("alias", alias)
        _setter("apm_ref_id", apm_ref_id)
        _setter("apm_resource_id", apm_resource_id)
        _setter("deployment_id", deployment_id)
        _setter("elasticsearch_ref_id", elasticsearch_ref_id)
        _setter("elasticsearch_resource_id", elasticsearch_resource_id)
        _setter("enterprise_search_ref_id", enterprise_search_ref_id)
        _setter("enterprise_search_resource_id", enterprise_search_resource_id)
        _setter("integrations_server_ref_id", integrations_server_ref_id)
        _setter("integrations_server_resource_id", integrations_server_resource_id)
        _setter("kibana_ref_id", kibana_ref_id)
        _setter("kibana_resource_id", kibana_resource_id)
        _setter("name", name)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        Deployment alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmRefId")
    def apm_ref_id(self) -> str:
        """
        The APM resource reference.
        """
        return pulumi.get(self, "apm_ref_id")

    @property
    @pulumi.getter(name="apmResourceId")
    def apm_resource_id(self) -> str:
        """
        The APM resource unique ID.
        """
        return pulumi.get(self, "apm_resource_id")

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        """
        The deployment unique ID.
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter(name="elasticsearchRefId")
    def elasticsearch_ref_id(self) -> str:
        """
        The Elasticsearch resource reference.
        """
        return pulumi.get(self, "elasticsearch_ref_id")

    @property
    @pulumi.getter(name="elasticsearchResourceId")
    def elasticsearch_resource_id(self) -> str:
        """
        The Elasticsearch resource unique ID.
        """
        return pulumi.get(self, "elasticsearch_resource_id")

    @property
    @pulumi.getter(name="enterpriseSearchRefId")
    def enterprise_search_ref_id(self) -> str:
        """
        The Enterprise Search resource reference.
        """
        return pulumi.get(self, "enterprise_search_ref_id")

    @property
    @pulumi.getter(name="enterpriseSearchResourceId")
    def enterprise_search_resource_id(self) -> str:
        """
        The Enterprise Search resource unique ID.
        """
        return pulumi.get(self, "enterprise_search_resource_id")

    @property
    @pulumi.getter(name="integrationsServerRefId")
    def integrations_server_ref_id(self) -> str:
        """
        The Integrations Server resource reference.
        """
        return pulumi.get(self, "integrations_server_ref_id")

    @property
    @pulumi.getter(name="integrationsServerResourceId")
    def integrations_server_resource_id(self) -> str:
        """
        The Integrations Server resource unique ID.
        """
        return pulumi.get(self, "integrations_server_resource_id")

    @property
    @pulumi.getter(name="kibanaRefId")
    def kibana_ref_id(self) -> str:
        """
        The Kibana resource reference.
        """
        return pulumi.get(self, "kibana_ref_id")

    @property
    @pulumi.getter(name="kibanaResourceId")
    def kibana_resource_id(self) -> str:
        """
        The Kibana resource unique ID.
        """
        return pulumi.get(self, "kibana_resource_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the deployment.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDeploymentsElasticsearchResult(dict):
    def __init__(__self__, *,
                 healthy: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str healthy: Overall health status of the resource instances.
        :param str status: Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        :param str version: Elastic stack version.
        """
        GetDeploymentsElasticsearchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy=healthy,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy: Optional[str] = None,
             status: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if healthy is not None:
            _setter("healthy", healthy)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[str]:
        """
        Overall health status of the resource instances.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentsEnterpriseSearchResult(dict):
    def __init__(__self__, *,
                 healthy: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str healthy: Overall health status of the resource instances.
        :param str status: Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        :param str version: Elastic stack version.
        """
        GetDeploymentsEnterpriseSearchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy=healthy,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy: Optional[str] = None,
             status: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if healthy is not None:
            _setter("healthy", healthy)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[str]:
        """
        Overall health status of the resource instances.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentsIntegrationsServerResult(dict):
    def __init__(__self__, *,
                 healthy: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str healthy: Overall health status of the resource instances.
        :param str status: Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        :param str version: Elastic stack version.
        """
        GetDeploymentsIntegrationsServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy=healthy,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy: Optional[str] = None,
             status: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if healthy is not None:
            _setter("healthy", healthy)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[str]:
        """
        Overall health status of the resource instances.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDeploymentsKibanaResult(dict):
    def __init__(__self__, *,
                 healthy: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str healthy: Overall health status of the resource instances.
        :param str status: Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        :param str version: Elastic stack version.
        """
        GetDeploymentsKibanaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy=healthy,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy: Optional[str] = None,
             status: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if healthy is not None:
            _setter("healthy", healthy)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[str]:
        """
        Overall health status of the resource instances.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Elastic stack version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetStackApmResult(dict):
    def __init__(__self__, *,
                 capacity_constraints_max: int,
                 capacity_constraints_min: int,
                 compatible_node_types: Sequence[str],
                 denylists: Sequence[str],
                 docker_image: str):
        """
        :param int capacity_constraints_max: Maximum size of the instances.
        :param int capacity_constraints_min: Minimum size of the instances.
        :param Sequence[str] compatible_node_types: List of node types compatible with this one.
        :param Sequence[str] denylists: List of configuration options that cannot be overridden by user settings.
        :param str docker_image: Docker image to use for the APM instance.
        """
        GetStackApmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_constraints_max=capacity_constraints_max,
            capacity_constraints_min=capacity_constraints_min,
            compatible_node_types=compatible_node_types,
            denylists=denylists,
            docker_image=docker_image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_constraints_max: Optional[int] = None,
             capacity_constraints_min: Optional[int] = None,
             compatible_node_types: Optional[Sequence[str]] = None,
             denylists: Optional[Sequence[str]] = None,
             docker_image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if capacity_constraints_max is None and 'capacityConstraintsMax' in kwargs:
            capacity_constraints_max = kwargs['capacityConstraintsMax']
        if capacity_constraints_max is None:
            raise TypeError("Missing 'capacity_constraints_max' argument")
        if capacity_constraints_min is None and 'capacityConstraintsMin' in kwargs:
            capacity_constraints_min = kwargs['capacityConstraintsMin']
        if capacity_constraints_min is None:
            raise TypeError("Missing 'capacity_constraints_min' argument")
        if compatible_node_types is None and 'compatibleNodeTypes' in kwargs:
            compatible_node_types = kwargs['compatibleNodeTypes']
        if compatible_node_types is None:
            raise TypeError("Missing 'compatible_node_types' argument")
        if denylists is None:
            raise TypeError("Missing 'denylists' argument")
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if docker_image is None:
            raise TypeError("Missing 'docker_image' argument")

        _setter("capacity_constraints_max", capacity_constraints_max)
        _setter("capacity_constraints_min", capacity_constraints_min)
        _setter("compatible_node_types", compatible_node_types)
        _setter("denylists", denylists)
        _setter("docker_image", docker_image)

    @property
    @pulumi.getter(name="capacityConstraintsMax")
    def capacity_constraints_max(self) -> int:
        """
        Maximum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_max")

    @property
    @pulumi.getter(name="capacityConstraintsMin")
    def capacity_constraints_min(self) -> int:
        """
        Minimum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_min")

    @property
    @pulumi.getter(name="compatibleNodeTypes")
    def compatible_node_types(self) -> Sequence[str]:
        """
        List of node types compatible with this one.
        """
        return pulumi.get(self, "compatible_node_types")

    @property
    @pulumi.getter
    def denylists(self) -> Sequence[str]:
        """
        List of configuration options that cannot be overridden by user settings.
        """
        return pulumi.get(self, "denylists")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        """
        Docker image to use for the APM instance.
        """
        return pulumi.get(self, "docker_image")


@pulumi.output_type
class GetStackElasticsearchResult(dict):
    def __init__(__self__, *,
                 capacity_constraints_max: int,
                 capacity_constraints_min: int,
                 compatible_node_types: Sequence[str],
                 default_plugins: Sequence[str],
                 denylists: Sequence[str],
                 docker_image: str,
                 plugins: Sequence[str]):
        """
        :param int capacity_constraints_max: Maximum size of the instances.
        :param int capacity_constraints_min: Minimum size of the instances.
        :param Sequence[str] compatible_node_types: List of node types compatible with this one.
        :param Sequence[str] default_plugins: List of default plugins.
        :param Sequence[str] denylists: List of configuration options that cannot be overridden by user settings.
        :param str docker_image: Docker image to use for the Elasticsearch cluster instances.
        :param Sequence[str] plugins: List of available plugins to be specified by users in Elasticsearch cluster instances.
        """
        GetStackElasticsearchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_constraints_max=capacity_constraints_max,
            capacity_constraints_min=capacity_constraints_min,
            compatible_node_types=compatible_node_types,
            default_plugins=default_plugins,
            denylists=denylists,
            docker_image=docker_image,
            plugins=plugins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_constraints_max: Optional[int] = None,
             capacity_constraints_min: Optional[int] = None,
             compatible_node_types: Optional[Sequence[str]] = None,
             default_plugins: Optional[Sequence[str]] = None,
             denylists: Optional[Sequence[str]] = None,
             docker_image: Optional[str] = None,
             plugins: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if capacity_constraints_max is None and 'capacityConstraintsMax' in kwargs:
            capacity_constraints_max = kwargs['capacityConstraintsMax']
        if capacity_constraints_max is None:
            raise TypeError("Missing 'capacity_constraints_max' argument")
        if capacity_constraints_min is None and 'capacityConstraintsMin' in kwargs:
            capacity_constraints_min = kwargs['capacityConstraintsMin']
        if capacity_constraints_min is None:
            raise TypeError("Missing 'capacity_constraints_min' argument")
        if compatible_node_types is None and 'compatibleNodeTypes' in kwargs:
            compatible_node_types = kwargs['compatibleNodeTypes']
        if compatible_node_types is None:
            raise TypeError("Missing 'compatible_node_types' argument")
        if default_plugins is None and 'defaultPlugins' in kwargs:
            default_plugins = kwargs['defaultPlugins']
        if default_plugins is None:
            raise TypeError("Missing 'default_plugins' argument")
        if denylists is None:
            raise TypeError("Missing 'denylists' argument")
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if docker_image is None:
            raise TypeError("Missing 'docker_image' argument")
        if plugins is None:
            raise TypeError("Missing 'plugins' argument")

        _setter("capacity_constraints_max", capacity_constraints_max)
        _setter("capacity_constraints_min", capacity_constraints_min)
        _setter("compatible_node_types", compatible_node_types)
        _setter("default_plugins", default_plugins)
        _setter("denylists", denylists)
        _setter("docker_image", docker_image)
        _setter("plugins", plugins)

    @property
    @pulumi.getter(name="capacityConstraintsMax")
    def capacity_constraints_max(self) -> int:
        """
        Maximum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_max")

    @property
    @pulumi.getter(name="capacityConstraintsMin")
    def capacity_constraints_min(self) -> int:
        """
        Minimum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_min")

    @property
    @pulumi.getter(name="compatibleNodeTypes")
    def compatible_node_types(self) -> Sequence[str]:
        """
        List of node types compatible with this one.
        """
        return pulumi.get(self, "compatible_node_types")

    @property
    @pulumi.getter(name="defaultPlugins")
    def default_plugins(self) -> Sequence[str]:
        """
        List of default plugins.
        """
        return pulumi.get(self, "default_plugins")

    @property
    @pulumi.getter
    def denylists(self) -> Sequence[str]:
        """
        List of configuration options that cannot be overridden by user settings.
        """
        return pulumi.get(self, "denylists")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        """
        Docker image to use for the Elasticsearch cluster instances.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter
    def plugins(self) -> Sequence[str]:
        """
        List of available plugins to be specified by users in Elasticsearch cluster instances.
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class GetStackEnterpriseSearchResult(dict):
    def __init__(__self__, *,
                 capacity_constraints_max: int,
                 capacity_constraints_min: int,
                 compatible_node_types: Sequence[str],
                 denylists: Sequence[str],
                 docker_image: str):
        """
        :param int capacity_constraints_max: Maximum size of the instances.
        :param int capacity_constraints_min: Minimum size of the instances.
        :param Sequence[str] compatible_node_types: List of node types compatible with this one.
        :param Sequence[str] denylists: List of configuration options that cannot be overridden by user settings.
        :param str docker_image: Docker image to use for the Enterprise Search instance.
        """
        GetStackEnterpriseSearchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_constraints_max=capacity_constraints_max,
            capacity_constraints_min=capacity_constraints_min,
            compatible_node_types=compatible_node_types,
            denylists=denylists,
            docker_image=docker_image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_constraints_max: Optional[int] = None,
             capacity_constraints_min: Optional[int] = None,
             compatible_node_types: Optional[Sequence[str]] = None,
             denylists: Optional[Sequence[str]] = None,
             docker_image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if capacity_constraints_max is None and 'capacityConstraintsMax' in kwargs:
            capacity_constraints_max = kwargs['capacityConstraintsMax']
        if capacity_constraints_max is None:
            raise TypeError("Missing 'capacity_constraints_max' argument")
        if capacity_constraints_min is None and 'capacityConstraintsMin' in kwargs:
            capacity_constraints_min = kwargs['capacityConstraintsMin']
        if capacity_constraints_min is None:
            raise TypeError("Missing 'capacity_constraints_min' argument")
        if compatible_node_types is None and 'compatibleNodeTypes' in kwargs:
            compatible_node_types = kwargs['compatibleNodeTypes']
        if compatible_node_types is None:
            raise TypeError("Missing 'compatible_node_types' argument")
        if denylists is None:
            raise TypeError("Missing 'denylists' argument")
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if docker_image is None:
            raise TypeError("Missing 'docker_image' argument")

        _setter("capacity_constraints_max", capacity_constraints_max)
        _setter("capacity_constraints_min", capacity_constraints_min)
        _setter("compatible_node_types", compatible_node_types)
        _setter("denylists", denylists)
        _setter("docker_image", docker_image)

    @property
    @pulumi.getter(name="capacityConstraintsMax")
    def capacity_constraints_max(self) -> int:
        """
        Maximum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_max")

    @property
    @pulumi.getter(name="capacityConstraintsMin")
    def capacity_constraints_min(self) -> int:
        """
        Minimum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_min")

    @property
    @pulumi.getter(name="compatibleNodeTypes")
    def compatible_node_types(self) -> Sequence[str]:
        """
        List of node types compatible with this one.
        """
        return pulumi.get(self, "compatible_node_types")

    @property
    @pulumi.getter
    def denylists(self) -> Sequence[str]:
        """
        List of configuration options that cannot be overridden by user settings.
        """
        return pulumi.get(self, "denylists")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        """
        Docker image to use for the Enterprise Search instance.
        """
        return pulumi.get(self, "docker_image")


@pulumi.output_type
class GetStackKibanaResult(dict):
    def __init__(__self__, *,
                 capacity_constraints_max: int,
                 capacity_constraints_min: int,
                 compatible_node_types: Sequence[str],
                 denylists: Sequence[str],
                 docker_image: str):
        """
        :param int capacity_constraints_max: Maximum size of the instances.
        :param int capacity_constraints_min: Minimum size of the instances.
        :param Sequence[str] compatible_node_types: List of node types compatible with this one.
        :param Sequence[str] denylists: List of configuration options that cannot be overridden by user settings.
        :param str docker_image: Docker image to use for the Kibana instance.
        """
        GetStackKibanaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_constraints_max=capacity_constraints_max,
            capacity_constraints_min=capacity_constraints_min,
            compatible_node_types=compatible_node_types,
            denylists=denylists,
            docker_image=docker_image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_constraints_max: Optional[int] = None,
             capacity_constraints_min: Optional[int] = None,
             compatible_node_types: Optional[Sequence[str]] = None,
             denylists: Optional[Sequence[str]] = None,
             docker_image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if capacity_constraints_max is None and 'capacityConstraintsMax' in kwargs:
            capacity_constraints_max = kwargs['capacityConstraintsMax']
        if capacity_constraints_max is None:
            raise TypeError("Missing 'capacity_constraints_max' argument")
        if capacity_constraints_min is None and 'capacityConstraintsMin' in kwargs:
            capacity_constraints_min = kwargs['capacityConstraintsMin']
        if capacity_constraints_min is None:
            raise TypeError("Missing 'capacity_constraints_min' argument")
        if compatible_node_types is None and 'compatibleNodeTypes' in kwargs:
            compatible_node_types = kwargs['compatibleNodeTypes']
        if compatible_node_types is None:
            raise TypeError("Missing 'compatible_node_types' argument")
        if denylists is None:
            raise TypeError("Missing 'denylists' argument")
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if docker_image is None:
            raise TypeError("Missing 'docker_image' argument")

        _setter("capacity_constraints_max", capacity_constraints_max)
        _setter("capacity_constraints_min", capacity_constraints_min)
        _setter("compatible_node_types", compatible_node_types)
        _setter("denylists", denylists)
        _setter("docker_image", docker_image)

    @property
    @pulumi.getter(name="capacityConstraintsMax")
    def capacity_constraints_max(self) -> int:
        """
        Maximum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_max")

    @property
    @pulumi.getter(name="capacityConstraintsMin")
    def capacity_constraints_min(self) -> int:
        """
        Minimum size of the instances.
        """
        return pulumi.get(self, "capacity_constraints_min")

    @property
    @pulumi.getter(name="compatibleNodeTypes")
    def compatible_node_types(self) -> Sequence[str]:
        """
        List of node types compatible with this one.
        """
        return pulumi.get(self, "compatible_node_types")

    @property
    @pulumi.getter
    def denylists(self) -> Sequence[str]:
        """
        List of configuration options that cannot be overridden by user settings.
        """
        return pulumi.get(self, "denylists")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        """
        Docker image to use for the Kibana instance.
        """
        return pulumi.get(self, "docker_image")


@pulumi.output_type
class GetTrafficFilterRulesetResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 include_by_default: bool,
                 name: str,
                 region: str,
                 rules: Sequence['outputs.GetTrafficFilterRulesetRuleResult']):
        """
        :param str description: The description of the ruleset.
        :param str id: The ID of the ruleset
        :param bool include_by_default: Should the ruleset be automatically included in the new deployments.
        :param str name: The name of the ruleset.
        :param str region: The ruleset can be attached only to deployments in the specific region.
        :param Sequence['GetTrafficFilterRulesetRuleArgs'] rules: An individual rule
        """
        GetTrafficFilterRulesetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            include_by_default=include_by_default,
            name=name,
            region=region,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             include_by_default: Optional[bool] = None,
             name: Optional[str] = None,
             region: Optional[str] = None,
             rules: Optional[Sequence['outputs.GetTrafficFilterRulesetRuleResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if include_by_default is None and 'includeByDefault' in kwargs:
            include_by_default = kwargs['includeByDefault']
        if include_by_default is None:
            raise TypeError("Missing 'include_by_default' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("include_by_default", include_by_default)
        _setter("name", name)
        _setter("region", region)
        _setter("rules", rules)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the ruleset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ruleset
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeByDefault")
    def include_by_default(self) -> bool:
        """
        Should the ruleset be automatically included in the new deployments.
        """
        return pulumi.get(self, "include_by_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The ruleset can be attached only to deployments in the specific region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetTrafficFilterRulesetRuleResult']:
        """
        An individual rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetTrafficFilterRulesetRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 source: str):
        """
        :param str description: The description of the ruleset.
        :param str id: The ID of the ruleset
        :param str source: Allowed traffic filter source: IP address, CIDR mask, or VPC endpoint ID.
        """
        GetTrafficFilterRulesetRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("source", source)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the ruleset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ruleset
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Allowed traffic filter source: IP address, CIDR mask, or VPC endpoint ID.
        """
        return pulumi.get(self, "source")


