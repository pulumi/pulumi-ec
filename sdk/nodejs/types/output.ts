// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DeploymentApm {
    /**
     * Optionally define the Apm configuration options for the APM Server
     */
    config?: outputs.DeploymentApmConfig;
    elasticsearchClusterRefId: string;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    refId: string;
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentApmConfig {
    /**
     * Optionally enable debug mode for APM servers - defaults to false
     */
    debugEnabled: boolean;
    /**
     * Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
     */
    dockerImage?: string;
    /**
     * An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsJson?: string;
    /**
     * An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideJson?: string;
    /**
     * An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideYaml?: string;
    /**
     * An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsYaml?: string;
}

export interface DeploymentElasticsearch {
    /**
     * Enable or disable autoscaling. Defaults to the setting coming from the deployment template.
     */
    autoscale: boolean;
    /**
     * The encoded Elasticsearch credentials to use in Beats or Logstash
     */
    cloudId: string;
    /**
     * 'cold' topology element
     */
    cold?: outputs.DeploymentElasticsearchCold;
    /**
     * Elasticsearch settings which will be applied to all topologies
     */
    config?: outputs.DeploymentElasticsearchConfig;
    /**
     * 'coordinating' topology element
     */
    coordinating?: outputs.DeploymentElasticsearchCoordinating;
    /**
     * Optional Elasticsearch extensions such as custom bundles or plugins.
     */
    extensions?: outputs.DeploymentElasticsearchExtension[];
    /**
     * 'frozen' topology element
     */
    frozen?: outputs.DeploymentElasticsearchFrozen;
    /**
     * 'hot' topology element
     */
    hot: outputs.DeploymentElasticsearchHot;
    /**
     * The Elasticsearch resource HTTP endpoint
     */
    httpEndpoint: string;
    /**
     * The Elasticsearch resource HTTPs endpoint
     */
    httpsEndpoint: string;
    /**
     * Keystore contents that are controlled by the deployment resource.
     */
    keystoreContents?: {[key: string]: outputs.DeploymentElasticsearchKeystoreContents};
    /**
     * 'master' topology element
     */
    master?: outputs.DeploymentElasticsearchMaster;
    /**
     * 'ml' topology element
     */
    ml?: outputs.DeploymentElasticsearchMl;
    /**
     * A human readable reference for the Elasticsearch resource. The default value `main-elasticsearch` is recommended.
     */
    refId: string;
    /**
     * The Elasticsearch resource region
     */
    region: string;
    /**
     * Optional Elasticsearch remote clusters to configure for the Elasticsearch resource, can be set multiple times
     */
    remoteClusters?: outputs.DeploymentElasticsearchRemoteCluster[];
    /**
     * The Elasticsearch resource unique identifier
     */
    resourceId: string;
    /**
     * (ECE only) Snapshot configuration settings for an Elasticsearch cluster.
     */
    snapshot: outputs.DeploymentElasticsearchSnapshot;
    snapshotSource?: outputs.DeploymentElasticsearchSnapshotSource;
    /**
     * Configuration strategy type autodetect, grow_and_shrink, rolling_grow_and_shrink, rolling_all
     */
    strategy?: string;
    /**
     * Optional Elasticsearch account trust settings.
     */
    trustAccounts: outputs.DeploymentElasticsearchTrustAccount[];
    /**
     * Optional Elasticsearch external trust settings.
     */
    trustExternals: outputs.DeploymentElasticsearchTrustExternal[];
    /**
     * 'warm' topology element
     */
    warm?: outputs.DeploymentElasticsearchWarm;
}

export interface DeploymentElasticsearchCold {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchColdAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchColdAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchConfig {
    /**
     * Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
     */
    dockerImage?: string;
    /**
     * List of Elasticsearch supported plugins, which vary from version to version. Check the Stack Pack version to see which plugins are supported for each version. This is currently only available from the UI and [ecctl](https://www.elastic.co/guide/en/ecctl/master/ecctl_stack_list.html)
     */
    plugins: string[];
    /**
     * An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsJson?: string;
    /**
     * An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideJson?: string;
    /**
     * An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideYaml?: string;
    /**
     * An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsYaml?: string;
}

export interface DeploymentElasticsearchCoordinating {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchCoordinatingAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchCoordinatingAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchExtension {
    /**
     * Extension name.
     */
    name: string;
    /**
     * Extension type, only `bundle` or `plugin` are supported.
     */
    type: string;
    /**
     * Bundle or plugin URL, the extension URL can be obtained from the `ec_deployment_extension.<name>.url` attribute or the API and cannot be a random HTTP address that is hosted elsewhere.
     */
    url: string;
    /**
     * Elasticsearch compatibility version. Bundles should specify major or minor versions with wildcards, such as `7.*` or `*` but **plugins must use full version notation down to the patch level**, such as `7.10.1` and wildcards are not allowed.
     */
    version: string;
}

export interface DeploymentElasticsearchFrozen {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchFrozenAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchFrozenAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchHot {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchHotAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchHotAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchKeystoreContents {
    /**
     * If true, the secret is handled as a file. Otherwise, it's handled as a plain string.
     */
    asFile: boolean;
    /**
     * Secret value. This can either be a string or a JSON object that is stored as a JSON string in the keystore.
     */
    value: string;
}

export interface DeploymentElasticsearchMaster {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchMasterAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchMasterAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchMl {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchMlAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchMlAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchRemoteCluster {
    /**
     * Alias for this Cross Cluster Search binding
     */
    alias: string;
    /**
     * Remote deployment ID
     */
    deploymentId: string;
    /**
     * Remote elasticsearch "refId", it is best left to the default value
     */
    refId: string;
    /**
     * If true, skip the cluster during search when disconnected
     */
    skipUnavailable: boolean;
}

export interface DeploymentElasticsearchSnapshot {
    /**
     * Indicates if Snapshotting is enabled.
     */
    enabled: boolean;
    /**
     * Snapshot repository configuration
     */
    repository: outputs.DeploymentElasticsearchSnapshotRepository;
}

export interface DeploymentElasticsearchSnapshotRepository {
    /**
     * Cluster snapshot reference repository settings, containing the repository name in ECE fashion
     */
    reference: outputs.DeploymentElasticsearchSnapshotRepositoryReference;
}

export interface DeploymentElasticsearchSnapshotRepositoryReference {
    /**
     * ECE snapshot repository name, from the '/platform/configuration/snapshots/repositories' endpoint
     */
    repositoryName: string;
}

export interface DeploymentElasticsearchSnapshotSource {
    /**
     * Name of the snapshot to restore. Use '**latest_success**' to get the most recent successful snapshot.
     */
    snapshotName: string;
    /**
     * ID of the Elasticsearch cluster that will be used as the source of the snapshot
     */
    sourceElasticsearchClusterId: string;
}

export interface DeploymentElasticsearchTrustAccount {
    /**
     * The ID of the Account.
     */
    accountId: string;
    /**
     * If true, all clusters in this account will by default be trusted and the `trustAllowlist` is ignored.
     */
    trustAll: boolean;
    /**
     * The list of clusters to trust. Only used when `trustAll` is false.
     */
    trustAllowlists?: string[];
}

export interface DeploymentElasticsearchTrustExternal {
    /**
     * The ID of the external trust relationship.
     */
    relationshipId: string;
    /**
     * If true, all clusters in this account will by default be trusted and the `trustAllowlist` is ignored.
     */
    trustAll: boolean;
    /**
     * The list of clusters to trust. Only used when `trustAll` is false.
     */
    trustAllowlists?: string[];
}

export interface DeploymentElasticsearchWarm {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscaling: outputs.DeploymentElasticsearchWarmAutoscaling;
    /**
     * Computed Instance Configuration ID of the topology element
     */
    instanceConfigurationId: string;
    /**
     * The computed list of node roles for the current topology element
     */
    nodeRoles: string[];
    /**
     * The node type for the Elasticsearch Topology element (data node)
     */
    nodeTypeData: string;
    /**
     * The node type for the Elasticsearch Topology element (ingest node)
     */
    nodeTypeIngest: string;
    /**
     * The node type for the Elasticsearch Topology element (master node)
     */
    nodeTypeMaster: string;
    /**
     * The node type for the Elasticsearch Topology element (machine learning node)
     */
    nodeTypeMl: string;
    /**
     * Amount of "sizeResource" per node in the "<size in GB>g" notation
     */
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    /**
     * Number of zones that the Elasticsearch cluster will span. This is used to set HA
     */
    zoneCount: number;
}

export interface DeploymentElasticsearchWarmAutoscaling {
    /**
     * Maximum size value for the maximum autoscaling setting.
     */
    maxSize: string;
    /**
     * Maximum resource type for the maximum autoscaling setting.
     */
    maxSizeResource: string;
    /**
     * Minimum size value for the minimum autoscaling setting.
     */
    minSize: string;
    /**
     * Minimum resource type for the minimum autoscaling setting.
     */
    minSizeResource: string;
    /**
     * Computed policy overrides set directly via the API or other clients.
     */
    policyOverrideJson: string;
}

export interface DeploymentEnterpriseSearch {
    /**
     * Optionally define the Enterprise Search configuration options for the Enterprise Search Server
     */
    config?: outputs.DeploymentEnterpriseSearchConfig;
    elasticsearchClusterRefId: string;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    nodeTypeAppserver: boolean;
    nodeTypeConnector: boolean;
    nodeTypeWorker: boolean;
    refId: string;
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentEnterpriseSearchConfig {
    /**
     * Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
     */
    dockerImage?: string;
    /**
     * An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsJson?: string;
    /**
     * An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideJson?: string;
    /**
     * An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideYaml?: string;
    /**
     * An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsYaml?: string;
}

export interface DeploymentIntegrationsServer {
    /**
     * Optionally define the Integrations Server configuration options for the IntegrationsServer Server
     */
    config?: outputs.DeploymentIntegrationsServerConfig;
    elasticsearchClusterRefId: string;
    /**
     * URLs for the accessing the Fleet and APM API's within this Integrations Server resource.
     */
    endpoints: outputs.DeploymentIntegrationsServerEndpoints;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    refId: string;
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentIntegrationsServerConfig {
    /**
     * Optionally enable debug mode for APM servers - defaults to false
     */
    debugEnabled: boolean;
    /**
     * Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
     */
    dockerImage?: string;
    /**
     * An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsJson?: string;
    /**
     * An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideJson?: string;
    /**
     * An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideYaml?: string;
    /**
     * An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsYaml?: string;
}

export interface DeploymentIntegrationsServerEndpoints {
    apm: string;
    fleet: string;
}

export interface DeploymentKibana {
    /**
     * Optionally define the Kibana configuration options for the Kibana Server
     */
    config?: outputs.DeploymentKibanaConfig;
    elasticsearchClusterRefId: string;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    refId: string;
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentKibanaConfig {
    /**
     * Optionally override the docker image the APM nodes will use. This option will not work in ESS customers and should only be changed if you know what you're doing.
     */
    dockerImage?: string;
    /**
     * An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*yaml' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (This field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsJson?: string;
    /**
     * An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*yaml' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideJson?: string;
    /**
     * An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user*settings*override*json' is allowed), ie in addition to the documented 'system*settings'. (This field together with 'system*settings' and 'user*settings*' defines the total set of resource settings)
     */
    userSettingsOverrideYaml?: string;
    /**
     * An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user*settings*json' is allowed), provided they are on the whitelist ('user*settings*whitelist') and not on the blacklist ('user*settings*blacklist'). (These field together with 'user*settings*override*' and 'system_settings' defines the total set of resource settings)
     */
    userSettingsYaml?: string;
}

export interface DeploymentObservability {
    deploymentId: string;
    logs: boolean;
    metrics: boolean;
    refId: string;
}

export interface DeploymentTrafficFilterRule {
    /**
     * Azure endpoint GUID. Only applicable when the ruleset type is set to `azurePrivateEndpoint`
     */
    azureEndpointGuid?: string;
    /**
     * Azure endpoint name. Only applicable when the ruleset type is set to `azurePrivateEndpoint`
     */
    azureEndpointName?: string;
    /**
     * Description of this individual rule
     */
    description?: string;
    /**
     * Computed rule ID
     */
    id: string;
    /**
     * Traffic filter source: IP address, CIDR mask, or VPC endpoint ID, **only required** when the type is not `azurePrivateEndpoint`
     */
    source?: string;
}

export interface GetDeploymentApm {
    /**
     * The locally-unique user-specified id of an APM Resource.
     */
    elasticsearchClusterRefId: string;
    /**
     * APM resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the APM resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the APM resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this APM resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * APM resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentApmTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentApmTopology {
    /**
     * Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
     */
    instanceConfigurationId: string;
    /**
     * Amount of "sizeResource" in Gigabytes. For example "4g".
     */
    size: string;
    /**
     * Type of resource ("memory" or "storage")
     */
    sizeResource: string;
    /**
     * Number of zones in which nodes will be placed.
     */
    zoneCount: number;
}

export interface GetDeploymentElasticsearch {
    /**
     * Whether or not Elasticsearch autoscaling is enabled.
     */
    autoscale: string;
    /**
     * The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana. See [Configure Beats and Logstash with Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html) for more information.
     */
    cloudId: string;
    /**
     * Elasticsearch resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the Elasticsearch resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the Elasticsearch resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Elasticsearch cluster.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Elasticsearch resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentElasticsearchTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentElasticsearchTopology {
    /**
     * Optional Elasticsearch autoscaling settings, such a maximum and minimum size and resources.
     */
    autoscalings: outputs.GetDeploymentElasticsearchTopologyAutoscaling[];
    /**
     * Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
     */
    instanceConfigurationId: string;
    /**
     * Defines the list of Elasticsearch node roles assigned to the topology element. This is supported from v7.10, and required from v8.
     */
    nodeRoles: string[];
    /**
     * Defines whether this node can hold data (\n\n).
     */
    nodeTypeData: boolean;
    /**
     * Defines whether this node can run an ingest pipeline (\n\n).
     */
    nodeTypeIngest: boolean;
    /**
     * Defines whether this node can be elected master (\n\n).
     */
    nodeTypeMaster: boolean;
    /**
     * Defines whether this node can run ML jobs (\n\n).
     */
    nodeTypeMl: boolean;
    /**
     * Amount of "sizeResource" in Gigabytes. For example "4g".
     */
    size: string;
    /**
     * Type of resource ("memory" or "storage")
     */
    sizeResource: string;
    /**
     * Number of zones in which nodes will be placed.
     */
    zoneCount: number;
}

export interface GetDeploymentElasticsearchTopologyAutoscaling {
    /**
     * Maximum size the tier can scale up to, e.g "64g".
     */
    maxSize: string;
    /**
     * Resource type used when specifying the maximum size the tier can scale up to.
     */
    maxSizeResource: string;
    /**
     * Minimum size the tier can scale down to when bidirectional autoscaling is supported.
     */
    minSize: string;
    /**
     * Resource type used when specifying the minimum size the tier can scale down to when bidirectional autoscaling is supported.
     */
    minSizeResource: string;
    /**
     * An arbitrary JSON object overriding the default autoscaling policy. Don't set unless you really know what you are doing.
     */
    policyOverrideJson: string;
}

export interface GetDeploymentEnterpriseSearch {
    /**
     * A locally-unique friendly alias for an Elasticsearch resource in this deployment.
     */
    elasticsearchClusterRefId: string;
    /**
     * Enterprise Search resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the Enterprise Search resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the Enterprise Search resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Enterprise Search resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Enterprise Search resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentEnterpriseSearchTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentEnterpriseSearchTopology {
    /**
     * Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
     */
    instanceConfigurationId: string;
    /**
     * Defines whether this instance should run as application/API server.
     */
    nodeTypeAppserver: boolean;
    /**
     * Defines whether this instance should run as connector.
     */
    nodeTypeConnector: boolean;
    /**
     * Defines whether this instance should run as background worker.
     */
    nodeTypeWorker: boolean;
    /**
     * Amount of "sizeResource" in Gigabytes. For example "4g".
     */
    size: string;
    /**
     * Type of resource ("memory" or "storage")
     */
    sizeResource: string;
    /**
     * Number of zones in which nodes will be placed.
     */
    zoneCount: number;
}

export interface GetDeploymentIntegrationsServer {
    /**
     * A locally-unique friendly alias for an Elasticsearch resource in this deployment.
     */
    elasticsearchClusterRefId: string;
    /**
     * Resource kind health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the resource kind.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the resource kind.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Integrations Server resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Resource kind status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentIntegrationsServerTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentIntegrationsServerTopology {
    /**
     * Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
     */
    instanceConfigurationId: string;
    /**
     * Amount of "sizeResource" in Gigabytes. For example "4g".
     */
    size: string;
    /**
     * Type of resource ("memory" or "storage")
     */
    sizeResource: string;
    /**
     * Number of zones in which nodes will be placed.
     */
    zoneCount: number;
}

export interface GetDeploymentKibana {
    /**
     * A locally-unique friendly alias for an Elasticsearch resource in this deployment.
     */
    elasticsearchClusterRefId: string;
    /**
     * Kibana resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the Kibana resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the Kibana resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Kibana resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Kibana resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentKibanaTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentKibanaTopology {
    /**
     * Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the ID of an existing instance configuration.
     */
    instanceConfigurationId: string;
    /**
     * Amount of "sizeResource" in Gigabytes. For example "4g".
     */
    size: string;
    /**
     * Type of resource ("memory" or "storage")
     */
    sizeResource: string;
    /**
     * Number of zones in which nodes will be placed.
     */
    zoneCount: number;
}

export interface GetDeploymentObservability {
    /**
     * Destination deployment ID for the shipped logs and monitoring metrics.
     */
    deploymentId: string;
    /**
     * Defines whether logs are shipped to the destination deployment.
     */
    logs: boolean;
    /**
     * Defines whether metrics are shipped to the destination deployment.
     */
    metrics: boolean;
    /**
     * Elasticsearch resource kind refId of the destination deployment.
     */
    refId: string;
}

export interface GetDeploymentsApm {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsDeployment {
    /**
     * Deployment alias.
     */
    alias: string;
    /**
     * The APM resource reference.
     */
    apmRefId: string;
    /**
     * The APM resource unique ID.
     */
    apmResourceId: string;
    /**
     * The deployment unique ID.
     */
    deploymentId: string;
    /**
     * The Elasticsearch resource reference.
     */
    elasticsearchRefId: string;
    /**
     * The Elasticsearch resource unique ID.
     */
    elasticsearchResourceId: string;
    /**
     * The Enterprise Search resource reference.
     */
    enterpriseSearchRefId: string;
    /**
     * The Enterprise Search resource unique ID.
     */
    enterpriseSearchResourceId: string;
    /**
     * The Integrations Server resource reference.
     */
    integrationsServerRefId: string;
    /**
     * The Integrations Server resource unique ID.
     */
    integrationsServerResourceId: string;
    /**
     * The Kibana resource reference.
     */
    kibanaRefId: string;
    /**
     * The Kibana resource unique ID.
     */
    kibanaResourceId: string;
    /**
     * The name of the deployment.
     */
    name: string;
}

export interface GetDeploymentsElasticsearch {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsEnterpriseSearch {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsIntegrationsServer {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsKibana {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetStackApm {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the APM instance.
     */
    dockerImage: string;
}

export interface GetStackElasticsearch {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of default plugins.
     */
    defaultPlugins: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the Elasticsearch cluster instances.
     */
    dockerImage: string;
    /**
     * List of available plugins to be specified by users in Elasticsearch cluster instances.
     */
    plugins: string[];
}

export interface GetStackEnterpriseSearch {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the Enterprise Search instance.
     */
    dockerImage: string;
}

export interface GetStackKibana {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the Kibana instance.
     */
    dockerImage: string;
}

export interface GetTrafficFilterRuleset {
    /**
     * The description of the ruleset.
     */
    description: string;
    /**
     * The ID of the ruleset
     */
    id: string;
    /**
     * Should the ruleset be automatically included in the new deployments.
     */
    includeByDefault: boolean;
    /**
     * The name of the ruleset.
     */
    name: string;
    /**
     * The ruleset can be attached only to deployments in the specific region.
     */
    region: string;
    /**
     * An individual rule
     */
    rules: outputs.GetTrafficFilterRulesetRule[];
}

export interface GetTrafficFilterRulesetRule {
    /**
     * The description of the ruleset.
     */
    description: string;
    /**
     * The ID of the ruleset
     */
    id: string;
    /**
     * Allowed traffic filter source: IP address, CIDR mask, or VPC endpoint ID.
     */
    source: string;
}

export interface SnapshotRepositoryGeneric {
    /**
     * An arbitrary JSON object containing the repository settings.
     */
    settings: string;
    /**
     * Repository type
     */
    type: string;
}

export interface SnapshotRepositoryS3 {
    /**
     * An S3 access key. If set, the secretKey setting must also be specified. If unset, the client will use the instance or container role instead.
     */
    accessKey?: string;
    /**
     * Name of the S3 bucket to use for snapshots.
     */
    bucket: string;
    /**
     * The S3 service endpoint to connect to. This defaults to s3.amazonaws.com but the AWS documentation lists alternative S3 endpoints. If you are using an S3-compatible service then you should set this to the serviceâ€™s endpoint.
     */
    endpoint?: string;
    /**
     * Whether to force the use of the path style access pattern. If true, the path style access pattern will be used. If false, the access pattern will be automatically determined by the AWS Java SDK (See AWS documentation for details). Defaults to false.
     */
    pathStyleAccess: boolean;
    /**
     * Allows specifying the signing region to use. Specifying this setting manually should not be necessary for most use cases. Generally, the SDK will correctly guess the signing region to use. It should be considered an expert level setting to support S3-compatible APIs that require v4 signatures and use a region other than the default us-east-1. Defaults to empty string which means that the SDK will try to automatically determine the correct signing region.
     */
    region?: string;
    /**
     * An S3 secret key. If set, the accessKey setting must also be specified.
     */
    secretKey?: string;
    /**
     * When set to true files are encrypted on server side using AES256 algorithm. Defaults to false.
     */
    serverSideEncryption: boolean;
}

