// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DeploymentApm {
    /**
     * Optionally define the Apm configuration options for the APM Server
     */
    config?: outputs.DeploymentApmConfig;
    elasticsearchClusterRefId: string;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    refId: string;
    /**
     * Elasticsearch Service (ESS) region where the deployment should be hosted. For Elastic Cloud Enterprise (ECE) installations, set to `"ece-region".
     */
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentApmConfig {
    debugEnabled: boolean;
    dockerImage?: string;
    userSettingsJson?: string;
    userSettingsOverrideJson?: string;
    userSettingsOverrideYaml?: string;
    userSettingsYaml?: string;
}

export interface DeploymentElasticsearch {
    /**
     * Enable or disable autoscaling. Defaults to the setting coming from the deployment template.
     */
    autoscale: boolean;
    cloudId: string;
    /**
     * 'cold' topology element
     */
    cold?: outputs.DeploymentElasticsearchCold;
    /**
     * Elasticsearch settings which will be applied to all topologies
     */
    config?: outputs.DeploymentElasticsearchConfig;
    /**
     * 'coordinating' topology element
     */
    coordinating?: outputs.DeploymentElasticsearchCoordinating;
    /**
     * Optional Elasticsearch extensions such as custom bundles or plugins.
     */
    extensions?: outputs.DeploymentElasticsearchExtension[];
    /**
     * 'frozen' topology element
     */
    frozen?: outputs.DeploymentElasticsearchFrozen;
    /**
     * 'hot' topology element
     */
    hot: outputs.DeploymentElasticsearchHot;
    httpEndpoint: string;
    httpsEndpoint: string;
    /**
     * Keystore contents that are controlled by the deployment resource.
     */
    keystoreContents?: {[key: string]: outputs.DeploymentElasticsearchKeystoreContents};
    /**
     * 'master' topology element
     */
    master?: outputs.DeploymentElasticsearchMaster;
    /**
     * 'ml' topology element
     */
    ml?: outputs.DeploymentElasticsearchMl;
    /**
     * A human readable reference for the Elasticsearch resource. The default value `main-elasticsearch` is recommended.
     */
    refId: string;
    /**
     * Elasticsearch Service (ESS) region where the deployment should be hosted. For Elastic Cloud Enterprise (ECE) installations, set to `"ece-region".
     */
    region: string;
    /**
     * Optional Elasticsearch remote clusters to configure for the Elasticsearch resource, can be set multiple times
     */
    remoteClusters?: outputs.DeploymentElasticsearchRemoteCluster[];
    resourceId: string;
    /**
     * (ECE only) Snapshot configuration settings for an Elasticsearch cluster.
     */
    snapshot: outputs.DeploymentElasticsearchSnapshot;
    snapshotSource?: outputs.DeploymentElasticsearchSnapshotSource;
    strategy?: string;
    trustAccounts: outputs.DeploymentElasticsearchTrustAccount[];
    trustExternals: outputs.DeploymentElasticsearchTrustExternal[];
    warm?: outputs.DeploymentElasticsearchWarm;
}

export interface DeploymentElasticsearchCold {
    autoscaling: outputs.DeploymentElasticsearchColdAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchColdAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchConfig {
    dockerImage?: string;
    plugins: string[];
    userSettingsJson?: string;
    userSettingsOverrideJson?: string;
    userSettingsOverrideYaml?: string;
    userSettingsYaml?: string;
}

export interface DeploymentElasticsearchCoordinating {
    autoscaling: outputs.DeploymentElasticsearchCoordinatingAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchCoordinatingAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchExtension {
    name: string;
    type: string;
    url: string;
    /**
     * Elastic Stack version to use for all of the deployment resources.
     */
    version: string;
}

export interface DeploymentElasticsearchFrozen {
    autoscaling: outputs.DeploymentElasticsearchFrozenAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchFrozenAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchHot {
    autoscaling: outputs.DeploymentElasticsearchHotAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchHotAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchKeystoreContents {
    asFile: boolean;
    value: string;
}

export interface DeploymentElasticsearchMaster {
    autoscaling: outputs.DeploymentElasticsearchMasterAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchMasterAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchMl {
    autoscaling: outputs.DeploymentElasticsearchMlAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchMlAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentElasticsearchRemoteCluster {
    alias: string;
    deploymentId: string;
    refId: string;
    skipUnavailable: boolean;
}

export interface DeploymentElasticsearchSnapshot {
    enabled: boolean;
    repository: outputs.DeploymentElasticsearchSnapshotRepository;
}

export interface DeploymentElasticsearchSnapshotRepository {
    reference: outputs.DeploymentElasticsearchSnapshotRepositoryReference;
}

export interface DeploymentElasticsearchSnapshotRepositoryReference {
    repositoryName: string;
}

export interface DeploymentElasticsearchSnapshotSource {
    snapshotName: string;
    sourceElasticsearchClusterId: string;
}

export interface DeploymentElasticsearchTrustAccount {
    accountId: string;
    trustAll: boolean;
    trustAllowlists?: string[];
}

export interface DeploymentElasticsearchTrustExternal {
    relationshipId: string;
    trustAll: boolean;
    trustAllowlists?: string[];
}

export interface DeploymentElasticsearchWarm {
    autoscaling: outputs.DeploymentElasticsearchWarmAutoscaling;
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: string;
    nodeTypeIngest: string;
    nodeTypeMaster: string;
    nodeTypeMl: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentElasticsearchWarmAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface DeploymentEnterpriseSearch {
    /**
     * Optionally define the Enterprise Search configuration options for the Enterprise Search Server
     */
    config?: outputs.DeploymentEnterpriseSearchConfig;
    elasticsearchClusterRefId: string;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    nodeTypeAppserver: boolean;
    nodeTypeConnector: boolean;
    nodeTypeWorker: boolean;
    refId: string;
    /**
     * Elasticsearch Service (ESS) region where the deployment should be hosted. For Elastic Cloud Enterprise (ECE) installations, set to `"ece-region".
     */
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentEnterpriseSearchConfig {
    dockerImage?: string;
    userSettingsJson?: string;
    userSettingsOverrideJson?: string;
    userSettingsOverrideYaml?: string;
    userSettingsYaml?: string;
}

export interface DeploymentIntegrationsServer {
    /**
     * Optionally define the Integrations Server configuration options for the IntegrationsServer Server
     */
    config?: outputs.DeploymentIntegrationsServerConfig;
    elasticsearchClusterRefId: string;
    /**
     * URLs for the accessing the Fleet and APM API's within this Integrations Server resource.
     */
    endpoints: outputs.DeploymentIntegrationsServerEndpoints;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    refId: string;
    /**
     * Elasticsearch Service (ESS) region where the deployment should be hosted. For Elastic Cloud Enterprise (ECE) installations, set to `"ece-region".
     */
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentIntegrationsServerConfig {
    debugEnabled: boolean;
    dockerImage?: string;
    userSettingsJson?: string;
    userSettingsOverrideJson?: string;
    userSettingsOverrideYaml?: string;
    userSettingsYaml?: string;
}

export interface DeploymentIntegrationsServerEndpoints {
    apm: string;
    fleet: string;
}

export interface DeploymentKibana {
    /**
     * Optionally define the Kibana configuration options for the Kibana Server
     */
    config?: outputs.DeploymentKibanaConfig;
    elasticsearchClusterRefId: string;
    httpEndpoint: string;
    httpsEndpoint: string;
    instanceConfigurationId: string;
    refId: string;
    /**
     * Elasticsearch Service (ESS) region where the deployment should be hosted. For Elastic Cloud Enterprise (ECE) installations, set to `"ece-region".
     */
    region: string;
    resourceId: string;
    size: string;
    /**
     * Optional size type, defaults to "memory".
     */
    sizeResource: string;
    zoneCount: number;
}

export interface DeploymentKibanaConfig {
    dockerImage?: string;
    userSettingsJson?: string;
    userSettingsOverrideJson?: string;
    userSettingsOverrideYaml?: string;
    userSettingsYaml?: string;
}

export interface DeploymentObservability {
    deploymentId: string;
    logs: boolean;
    metrics: boolean;
    refId: string;
}

export interface DeploymentTrafficFilterRule {
    /**
     * Azure endpoint GUID. Only applicable when the ruleset type is set to `azurePrivateEndpoint`
     */
    azureEndpointGuid?: string;
    /**
     * Azure endpoint name. Only applicable when the ruleset type is set to `azurePrivateEndpoint`
     */
    azureEndpointName?: string;
    /**
     * Description of this individual rule
     */
    description?: string;
    /**
     * Computed rule ID
     */
    id: string;
    /**
     * Traffic filter source: IP address, CIDR mask, or VPC endpoint ID, **only required** when the type is not `azurePrivateEndpoint`
     */
    source?: string;
}

export interface GetDeploymentApm {
    /**
     * The locally-unique user-specified id of an APM Resource.
     */
    elasticsearchClusterRefId: string;
    /**
     * APM resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the APM resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the APM resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this APM resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * APM resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentApmTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentApmTopology {
    instanceConfigurationId: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface GetDeploymentElasticsearch {
    /**
     * Whether or not Elasticsearch autoscaling is enabled.
     */
    autoscale: string;
    /**
     * The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana. See [Configure Beats and Logstash with Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html) for more information.
     */
    cloudId: string;
    /**
     * Elasticsearch resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the Elasticsearch resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the Elasticsearch resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Elasticsearch cluster.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Elasticsearch resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentElasticsearchTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentElasticsearchTopology {
    autoscalings: outputs.GetDeploymentElasticsearchTopologyAutoscaling[];
    instanceConfigurationId: string;
    nodeRoles: string[];
    nodeTypeData: boolean;
    nodeTypeIngest: boolean;
    nodeTypeMaster: boolean;
    nodeTypeMl: boolean;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface GetDeploymentElasticsearchTopologyAutoscaling {
    maxSize: string;
    maxSizeResource: string;
    minSize: string;
    minSizeResource: string;
    policyOverrideJson: string;
}

export interface GetDeploymentEnterpriseSearch {
    /**
     * A locally-unique friendly alias for an Elasticsearch resource in this deployment.
     */
    elasticsearchClusterRefId: string;
    /**
     * Enterprise Search resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the Enterprise Search resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the Enterprise Search resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Enterprise Search resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Enterprise Search resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentEnterpriseSearchTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentEnterpriseSearchTopology {
    instanceConfigurationId: string;
    nodeTypeAppserver: boolean;
    nodeTypeConnector: boolean;
    nodeTypeWorker: boolean;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface GetDeploymentIntegrationsServer {
    /**
     * A locally-unique friendly alias for an Elasticsearch resource in this deployment.
     */
    elasticsearchClusterRefId: string;
    /**
     * Resource kind health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the resource kind.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the resource kind.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Integrations Server resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Resource kind status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentIntegrationsServerTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentIntegrationsServerTopology {
    instanceConfigurationId: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface GetDeploymentKibana {
    /**
     * A locally-unique friendly alias for an Elasticsearch resource in this deployment.
     */
    elasticsearchClusterRefId: string;
    /**
     * Kibana resource health status.
     */
    healthy: boolean;
    /**
     * HTTP endpoint for the Kibana resource.
     */
    httpEndpoint: string;
    /**
     * HTTPS endpoint for the Kibana resource.
     */
    httpsEndpoint: string;
    /**
     * A locally-unique friendly alias for this Kibana resource.
     */
    refId: string;
    /**
     * The resource unique identifier.
     */
    resourceId: string;
    /**
     * Kibana resource status (for example, "started", "stopped", etc).
     */
    status: string;
    /**
     * Node topology element definition.
     */
    topologies: outputs.GetDeploymentKibanaTopology[];
    /**
     * Elastic stack version.
     */
    version: string;
}

export interface GetDeploymentKibanaTopology {
    instanceConfigurationId: string;
    size: string;
    sizeResource: string;
    zoneCount: number;
}

export interface GetDeploymentObservability {
    /**
     * Destination deployment ID for the shipped logs and monitoring metrics.
     */
    deploymentId: string;
    /**
     * Defines whether logs are shipped to the destination deployment.
     */
    logs: boolean;
    /**
     * Defines whether metrics are shipped to the destination deployment.
     */
    metrics: boolean;
    /**
     * Elasticsearch resource kind refId of the destination deployment.
     */
    refId: string;
}

export interface GetDeploymentsApm {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsDeployment {
    /**
     * Deployment alias.
     */
    alias: string;
    /**
     * The APM resource reference.
     */
    apmRefId: string;
    /**
     * The APM resource unique ID.
     */
    apmResourceId: string;
    /**
     * The deployment unique ID.
     */
    deploymentId: string;
    /**
     * The Elasticsearch resource reference.
     */
    elasticsearchRefId: string;
    /**
     * The Elasticsearch resource unique ID.
     */
    elasticsearchResourceId: string;
    /**
     * The Enterprise Search resource reference.
     */
    enterpriseSearchRefId: string;
    /**
     * The Enterprise Search resource unique ID.
     */
    enterpriseSearchResourceId: string;
    /**
     * The Integrations Server resource reference.
     */
    integrationsServerRefId: string;
    /**
     * The Integrations Server resource unique ID.
     */
    integrationsServerResourceId: string;
    /**
     * The Kibana resource reference.
     */
    kibanaRefId: string;
    /**
     * The Kibana resource unique ID.
     */
    kibanaResourceId: string;
    /**
     * The name of the deployment.
     */
    name: string;
}

export interface GetDeploymentsElasticsearch {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsEnterpriseSearch {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsIntegrationsServer {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetDeploymentsKibana {
    /**
     * Overall health status of the resource instances.
     */
    healthy?: string;
    /**
     * Resource kind status. Can be one of `initializing`, `stopping`, `stopped`, `rebooting`, `restarting`.
     */
    status?: string;
    /**
     * Elastic stack version.
     */
    version?: string;
}

export interface GetStackApm {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the APM instance.
     */
    dockerImage: string;
}

export interface GetStackElasticsearch {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of default plugins.
     */
    defaultPlugins: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the Elasticsearch cluster instances.
     */
    dockerImage: string;
    /**
     * List of available plugins to be specified by users in Elasticsearch cluster instances.
     */
    plugins: string[];
}

export interface GetStackEnterpriseSearch {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the Enterprise Search instance.
     */
    dockerImage: string;
}

export interface GetStackKibana {
    /**
     * Maximum size of the instances.
     */
    capacityConstraintsMax: number;
    /**
     * Minimum size of the instances.
     */
    capacityConstraintsMin: number;
    /**
     * List of node types compatible with this one.
     */
    compatibleNodeTypes: string[];
    /**
     * List of configuration options that cannot be overridden by user settings.
     */
    denylists: string[];
    /**
     * Docker image to use for the Kibana instance.
     */
    dockerImage: string;
}

export interface GetTrafficFilterRuleset {
    /**
     * The description of the ruleset.
     */
    description: string;
    /**
     * The ID of the ruleset
     */
    id: string;
    /**
     * Should the ruleset be automatically included in the new deployments.
     */
    includeByDefault: boolean;
    /**
     * The name of the ruleset.
     */
    name: string;
    /**
     * The ruleset can be attached only to deployments in the specific region.
     */
    region: string;
    /**
     * An individual rule
     */
    rules: outputs.GetTrafficFilterRulesetRule[];
}

export interface GetTrafficFilterRulesetRule {
    description: string;
    /**
     * The id of the traffic filter to select.
     */
    id: string;
    source: string;
}

export interface SnapshotRepositoryGeneric {
    /**
     * An arbitrary JSON object containing the repository settings.
     */
    settings: string;
    /**
     * Repository type
     */
    type: string;
}

export interface SnapshotRepositoryS3 {
    /**
     * An S3 access key. If set, the secretKey setting must also be specified. If unset, the client will use the instance or container role instead.
     */
    accessKey?: string;
    /**
     * Name of the S3 bucket to use for snapshots.
     */
    bucket: string;
    /**
     * The S3 service endpoint to connect to. This defaults to s3.amazonaws.com but the AWS documentation lists alternative S3 endpoints. If you are using an S3-compatible service then you should set this to the service’s endpoint.
     */
    endpoint?: string;
    /**
     * Whether to force the use of the path style access pattern. If true, the path style access pattern will be used. If false, the access pattern will be automatically determined by the AWS Java SDK (See AWS documentation for details). Defaults to false.
     */
    pathStyleAccess: boolean;
    /**
     * Allows specifying the signing region to use. Specifying this setting manually should not be necessary for most use cases. Generally, the SDK will correctly guess the signing region to use. It should be considered an expert level setting to support S3-compatible APIs that require v4 signatures and use a region other than the default us-east-1. Defaults to empty string which means that the SDK will try to automatically determine the correct signing region.
     */
    region?: string;
    /**
     * An S3 secret key. If set, the accessKey setting must also be specified.
     */
    secretKey?: string;
    /**
     * When set to true files are encrypted on server side using AES256 algorithm. Defaults to false.
     */
    serverSideEncryption: boolean;
}

