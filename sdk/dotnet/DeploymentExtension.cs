// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.ElasticCloud
{
    /// <summary>
    /// Provides an Elastic Cloud extension resource, which allows extensions to be created, updated, and deleted.
    /// 
    ///   Extensions allow users of Elastic Cloud to use custom plugins, scripts, or dictionaries to enhance the core functionality of Elasticsearch. Before you install an extension, be sure to check out the supported and official [Elasticsearch plugins](https://www.elastic.co/guide/en/elasticsearch/plugins/current/index.html) already available.
    /// 
    ///   **Tip :** If you experience timeouts when uploading an extension through a slow network, you might need to increase the timeout setting.
    /// 
    /// ## Example Usage
    /// 
    /// ### With extension file
    /// 
    /// ### With download URL
    /// 
    /// ## Import
    /// 
    /// Extensions can be imported using the `id`, for example:
    /// 
    /// ```sh
    /// $ pulumi import ec:index/deploymentExtension:DeploymentExtension name 320b7b540dfc967a7a649c18e2fce4ed
    /// ```
    /// </summary>
    [ElasticCloudResourceType("ec:index/deploymentExtension:DeploymentExtension")]
    public partial class DeploymentExtension : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Description for the extension
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// The URL to download the extension archive.
        /// </summary>
        [Output("downloadUrl")]
        public Output<string> DownloadUrl { get; private set; } = null!;

        /// <summary>
        /// Extension type. Must be `Bundle` or `Plugin`. A `Bundle` will usually contain a dictionary or script, where a `Plugin` is compiled from source.
        /// </summary>
        [Output("extensionType")]
        public Output<string> ExtensionType { get; private set; } = null!;

        /// <summary>
        /// Hash value of the file. Triggers re-uploading the file on change.
        /// </summary>
        [Output("fileHash")]
        public Output<string?> FileHash { get; private set; } = null!;

        /// <summary>
        /// Local file path to upload as the extension.
        /// </summary>
        [Output("filePath")]
        public Output<string?> FilePath { get; private set; } = null!;

        /// <summary>
        /// The datatime the extension was last modified.
        /// </summary>
        [Output("lastModified")]
        public Output<string> LastModified { get; private set; } = null!;

        /// <summary>
        /// Name of the extension
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The size of the extension file in bytes.
        /// </summary>
        [Output("size")]
        public Output<int> Size { get; private set; } = null!;

        /// <summary>
        /// The extension URL which will be used in the Elastic Cloud deployment plan.
        /// </summary>
        [Output("url")]
        public Output<string> Url { get; private set; } = null!;

        /// <summary>
        /// Elastic stack version. A full version (e.g 8.7.0) should be set for plugins. A wildcard (e.g 8.*) may be used for bundles.
        /// </summary>
        [Output("version")]
        public Output<string> Version { get; private set; } = null!;


        /// <summary>
        /// Create a DeploymentExtension resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DeploymentExtension(string name, DeploymentExtensionArgs args, CustomResourceOptions? options = null)
            : base("ec:index/deploymentExtension:DeploymentExtension", name, args ?? new DeploymentExtensionArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DeploymentExtension(string name, Input<string> id, DeploymentExtensionState? state = null, CustomResourceOptions? options = null)
            : base("ec:index/deploymentExtension:DeploymentExtension", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DeploymentExtension resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DeploymentExtension Get(string name, Input<string> id, DeploymentExtensionState? state = null, CustomResourceOptions? options = null)
        {
            return new DeploymentExtension(name, id, state, options);
        }
    }

    public sealed class DeploymentExtensionArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Description for the extension
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The URL to download the extension archive.
        /// </summary>
        [Input("downloadUrl")]
        public Input<string>? DownloadUrl { get; set; }

        /// <summary>
        /// Extension type. Must be `Bundle` or `Plugin`. A `Bundle` will usually contain a dictionary or script, where a `Plugin` is compiled from source.
        /// </summary>
        [Input("extensionType", required: true)]
        public Input<string> ExtensionType { get; set; } = null!;

        /// <summary>
        /// Hash value of the file. Triggers re-uploading the file on change.
        /// </summary>
        [Input("fileHash")]
        public Input<string>? FileHash { get; set; }

        /// <summary>
        /// Local file path to upload as the extension.
        /// </summary>
        [Input("filePath")]
        public Input<string>? FilePath { get; set; }

        /// <summary>
        /// Name of the extension
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Elastic stack version. A full version (e.g 8.7.0) should be set for plugins. A wildcard (e.g 8.*) may be used for bundles.
        /// </summary>
        [Input("version", required: true)]
        public Input<string> Version { get; set; } = null!;

        public DeploymentExtensionArgs()
        {
        }
        public static new DeploymentExtensionArgs Empty => new DeploymentExtensionArgs();
    }

    public sealed class DeploymentExtensionState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Description for the extension
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The URL to download the extension archive.
        /// </summary>
        [Input("downloadUrl")]
        public Input<string>? DownloadUrl { get; set; }

        /// <summary>
        /// Extension type. Must be `Bundle` or `Plugin`. A `Bundle` will usually contain a dictionary or script, where a `Plugin` is compiled from source.
        /// </summary>
        [Input("extensionType")]
        public Input<string>? ExtensionType { get; set; }

        /// <summary>
        /// Hash value of the file. Triggers re-uploading the file on change.
        /// </summary>
        [Input("fileHash")]
        public Input<string>? FileHash { get; set; }

        /// <summary>
        /// Local file path to upload as the extension.
        /// </summary>
        [Input("filePath")]
        public Input<string>? FilePath { get; set; }

        /// <summary>
        /// The datatime the extension was last modified.
        /// </summary>
        [Input("lastModified")]
        public Input<string>? LastModified { get; set; }

        /// <summary>
        /// Name of the extension
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The size of the extension file in bytes.
        /// </summary>
        [Input("size")]
        public Input<int>? Size { get; set; }

        /// <summary>
        /// The extension URL which will be used in the Elastic Cloud deployment plan.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

        /// <summary>
        /// Elastic stack version. A full version (e.g 8.7.0) should be set for plugins. A wildcard (e.g 8.*) may be used for bundles.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public DeploymentExtensionState()
        {
        }
        public static new DeploymentExtensionState Empty => new DeploymentExtensionState();
    }
}
