// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.ElasticCloud
{
    /// <summary>
    /// Provides an Elastic Cloud extension resource, which allows extensions to be created, updated, and deleted.
    /// 
    /// Extensions allow users of Elastic Cloud to use custom plugins, scripts, or dictionaries to enhance the core functionality of Elasticsearch. Before you install an extension, be sure to check out the supported and official [Elasticsearch plugins](https://www.elastic.co/guide/en/elasticsearch/plugins/current/index.html) already available.
    /// 
    /// ## Example Usage
    /// ### With download URL
    /// ```csharp
    /// using Pulumi;
    /// using ElasticCloud = Pulumi.ElasticCloud;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleExtension = new ElasticCloud.DeploymentExtension("exampleExtension", new ElasticCloud.DeploymentExtensionArgs
    ///         {
    ///             Description = "my extension",
    ///             DownloadUrl = "https://example.net",
    ///             ExtensionType = "bundle",
    ///             Version = "*",
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### Using extension in ec.Deployment
    /// ```csharp
    /// using Pulumi;
    /// using ElasticCloud = Pulumi.ElasticCloud;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleExtension = new ElasticCloud.DeploymentExtension("exampleExtension", new ElasticCloud.DeploymentExtensionArgs
    ///         {
    ///             Description = "my extension",
    ///             Version = "*",
    ///             ExtensionType = "bundle",
    ///             DownloadUrl = "https://example.net",
    ///         });
    ///         var latest = Output.Create(ElasticCloud.GetStack.InvokeAsync(new ElasticCloud.GetStackArgs
    ///         {
    ///             VersionRegex = "latest",
    ///             Region = "us-east-1",
    ///         }));
    ///         var withExtension = new ElasticCloud.Deployment("withExtension", new ElasticCloud.DeploymentArgs
    ///         {
    ///             Region = "us-east-1",
    ///             Version = latest.Apply(latest =&gt; latest.Version),
    ///             DeploymentTemplateId = "aws-io-optimized-v2",
    ///             Elasticsearch = new ElasticCloud.Inputs.DeploymentElasticsearchArgs
    ///             {
    ///                 Extensions = 
    ///                 {
    ///                     new ElasticCloud.Inputs.DeploymentElasticsearchExtensionArgs
    ///                     {
    ///                         Name = exampleExtension.Name,
    ///                         Type = "bundle",
    ///                         Version = latest.Apply(latest =&gt; latest.Version),
    ///                         Url = exampleExtension.Url,
    ///                     },
    ///                 },
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// 
    /// ## Import
    /// 
    /// You can import extensions using the `id`, for example
    /// 
    /// ```sh
    ///  $ pulumi import ec:index/deploymentExtension:DeploymentExtension name 320b7b540dfc967a7a649c18e2fce4ed
    /// ```
    /// </summary>
    [ElasticCloudResourceType("ec:index/deploymentExtension:DeploymentExtension")]
    public partial class DeploymentExtension : Pulumi.CustomResource
    {
        /// <summary>
        /// Description of the extension.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The URL to download the extension archive.
        /// </summary>
        [Output("downloadUrl")]
        public Output<string?> DownloadUrl { get; private set; } = null!;

        /// <summary>
        /// `bundle` or `plugin` allowed. A `bundle` will usually contain a dictionary or script, where a `plugin` is compiled from source.
        /// </summary>
        [Output("extensionType")]
        public Output<string> ExtensionType { get; private set; } = null!;

        /// <summary>
        /// Hash value of the file. If it is changed, the file is reuploaded.
        /// </summary>
        [Output("fileHash")]
        public Output<string?> FileHash { get; private set; } = null!;

        /// <summary>
        /// File path of the extension uploaded.
        /// </summary>
        [Output("filePath")]
        public Output<string?> FilePath { get; private set; } = null!;

        /// <summary>
        /// The datetime the extension was last modified.
        /// </summary>
        [Output("lastModified")]
        public Output<string> LastModified { get; private set; } = null!;

        /// <summary>
        /// Name of the extension.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The extension file size in bytes.
        /// </summary>
        [Output("size")]
        public Output<int> Size { get; private set; } = null!;

        /// <summary>
        /// The extension URL to be used in the plan.
        /// </summary>
        [Output("url")]
        public Output<string> Url { get; private set; } = null!;

        /// <summary>
        /// Elastic stack version, a numeric version for plugins, e.g. 2.3.0 should be set. Major version e.g. 2.*, or wildcards e.g. * for bundles.
        /// </summary>
        [Output("version")]
        public Output<string> Version { get; private set; } = null!;


        /// <summary>
        /// Create a DeploymentExtension resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DeploymentExtension(string name, DeploymentExtensionArgs args, CustomResourceOptions? options = null)
            : base("ec:index/deploymentExtension:DeploymentExtension", name, args ?? new DeploymentExtensionArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DeploymentExtension(string name, Input<string> id, DeploymentExtensionState? state = null, CustomResourceOptions? options = null)
            : base("ec:index/deploymentExtension:DeploymentExtension", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DeploymentExtension resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DeploymentExtension Get(string name, Input<string> id, DeploymentExtensionState? state = null, CustomResourceOptions? options = null)
        {
            return new DeploymentExtension(name, id, state, options);
        }
    }

    public sealed class DeploymentExtensionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Description of the extension.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The URL to download the extension archive.
        /// </summary>
        [Input("downloadUrl")]
        public Input<string>? DownloadUrl { get; set; }

        /// <summary>
        /// `bundle` or `plugin` allowed. A `bundle` will usually contain a dictionary or script, where a `plugin` is compiled from source.
        /// </summary>
        [Input("extensionType", required: true)]
        public Input<string> ExtensionType { get; set; } = null!;

        /// <summary>
        /// Hash value of the file. If it is changed, the file is reuploaded.
        /// </summary>
        [Input("fileHash")]
        public Input<string>? FileHash { get; set; }

        /// <summary>
        /// File path of the extension uploaded.
        /// </summary>
        [Input("filePath")]
        public Input<string>? FilePath { get; set; }

        /// <summary>
        /// Name of the extension.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Elastic stack version, a numeric version for plugins, e.g. 2.3.0 should be set. Major version e.g. 2.*, or wildcards e.g. * for bundles.
        /// </summary>
        [Input("version", required: true)]
        public Input<string> Version { get; set; } = null!;

        public DeploymentExtensionArgs()
        {
        }
    }

    public sealed class DeploymentExtensionState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Description of the extension.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The URL to download the extension archive.
        /// </summary>
        [Input("downloadUrl")]
        public Input<string>? DownloadUrl { get; set; }

        /// <summary>
        /// `bundle` or `plugin` allowed. A `bundle` will usually contain a dictionary or script, where a `plugin` is compiled from source.
        /// </summary>
        [Input("extensionType")]
        public Input<string>? ExtensionType { get; set; }

        /// <summary>
        /// Hash value of the file. If it is changed, the file is reuploaded.
        /// </summary>
        [Input("fileHash")]
        public Input<string>? FileHash { get; set; }

        /// <summary>
        /// File path of the extension uploaded.
        /// </summary>
        [Input("filePath")]
        public Input<string>? FilePath { get; set; }

        /// <summary>
        /// The datetime the extension was last modified.
        /// </summary>
        [Input("lastModified")]
        public Input<string>? LastModified { get; set; }

        /// <summary>
        /// Name of the extension.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The extension file size in bytes.
        /// </summary>
        [Input("size")]
        public Input<int>? Size { get; set; }

        /// <summary>
        /// The extension URL to be used in the plan.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

        /// <summary>
        /// Elastic stack version, a numeric version for plugins, e.g. 2.3.0 should be set. Major version e.g. 2.*, or wildcards e.g. * for bundles.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public DeploymentExtensionState()
        {
        }
    }
}
